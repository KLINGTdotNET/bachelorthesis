\newglossaryentry{URI}{
	name=\textsc{Uri},
	description={
	    Ein \enquote{Uniform Resource Identifier} (\gls{URI}) ist eine kompakte Zeichenkette zur Identifizierung einer abstrakten oder physischen Ressource. \ldots{} Eine Ressource ist alles was identifizierbar ist, beispielsweise elektronische Dokumente, Bilder, Dienste und Sammlungen von Ressourcen. (eigene Übersetzung von \cite{w3cURI}).
		%\emph{Unified Resource Identifier} ist ein Folge von Zeichen, die einen Name oder eine Web-Ressource identifiziert	
	},
	plural=\textsc{Uri}s
}

\newglossaryentry{URL}{
	name=\textsc{Url},
	description={
		%\emph{Unified Resource Locator} sind eine Untermenge der \emph{URIs}. Der Unterschied besteht in der expliziten Angabe des Zugrissmechanismus und des Ortes (\enquote{Location}) durch \emph{URLs}, beispielsweise \texttt{http} oder \texttt{ftp}
	    Der Begriff \enquote{Uniform Resource Locator} (\gls{URL}) bezieht sich auf eine Teilmenge von \glspl{URI}. \glspl{URL} identifizieren Ressourcen über den Zugriffsmechanismus, anstelle des Namens oder anderer Attribute der Ressource.
    	(eigene Übersetzung von \cite{w3cURI}).   
	},
	plural=\textsc{Url}s,
	see=URI
}

\newglossaryentry{URN}{
	name=\textsc{Urn},
	description={
	    Eine Teilmenge der \glspl{URI}, die sogenannten \enquote{Uniform Resource Names} (\glspl{URN}), sind global eindeutige und beständige Bezeichner für Ressourcen. Sie müssen verfügbar bleiben auch wenn die bezeichnete Ressource nicht mehr erreichbar oder vorhanden ist. \ldots{} Der Unterschied zu einer \gls{URL} besteht darin, das ihr primärer Zweck in der dauerhaften Auszeichnung einer Ressource mit einem Bezeichner besteht.
    	(eigene Übersetzung von \cite{w3cURI}).
	},
	plural=\textsc{Urn}s,
	see=URI
}

\newglossaryentry{OSI}{
	name=\textsc{Osi}-Modell,
	description={
		Das \textsc{Osi}-Modell (\enquote{Open Systems Interconnection}) ist ein Konzeptuelles Modell, dass Funktionalitäten von Netzwerkprotokollen durch die Aufteilung in Abstraktionsschichten beschreibt und vereinheitlicht \cite{wiki:osi}
	}
}

\newglossaryentry{HTTP}{
	name=\textsc{Http},
	description={
		Das \emph{Hypertext Transfer Protocol (\textsc{Http})} ist ein allgemeines und \emph{zustandsloses} Protokoll, zur Übertragung von Daten über ein Netzwerk, was durch Erweiterung seiner Anfragemethoden, Statuscodes und Header für viele unterschiedliche Anwendungen verwendet werden kann (\cite[][Abstract]{rfc2616})
	}
}

\newglossaryentry{Typsystem}{
	name=Typsystem,
	description={
		Ein Typsystem ordnet den Programmelementen Typen zu und prüft die Konformität dieser Typen nach bestimmten vordefinierten Regeln
	}
}

\newglossaryentry{Datenmodell}{
	name=Datenmodell,
	description={
	    Ein Datenmodell ist im Grunde die Darstellung eines Informationsmodells unter Berücksichtigung einer Menge von Mechanismen für die Darstellung, Organisierung, Speicherung und Bearbeitung von Daten.
	    Das Modell besteht aus einer Sammlung von \ldots
	    \begin{compactitem}
	        \item{Datenstrukturen, wie Listen, Tabellen, Relationen etc.}
	        \item{Operationen die auf die Strukturen angewendet werden können, wie Abfrage, Aktualisierung, ...}
	        \item{Integritätsbedingungen die gültige Zustände (Menge von Werten) odder Zustandsänderungen (Operationen auf Werten) definieren.}
	    \end{compactitem}
	}
}

\newglossaryentry{Konzeptuelles_Modell}{
	name=Konzeptuelles Modell,
	description={
	    Ein \emph{Konzeptuelles Modell} beschreibt alle Objekte, Attribute, Rollen und Beziehungen sowie die Beschränkungen einer bestimmten Problemdomäne\footnote{Teil einer Applikation oder Fachbereich, der untersucht werden muss um die Problemstellung zu lösen \cite{wiki:problemdomain}}.
    	Bei der Erstellung des Modells werden explizit Design- und Implementierungsentscheidungen außer acht gelassen. 
    	Das Ziel ist die Bedeutung von Begriffen und Konzepten aus der Domäne zu formalisieren, Beziehungen zwischen den Konzepten finden und Mehrdeutigkeiten bei der Nutzung der Domänentermini zu vermeiden
	}
}

\newglossaryentry{Codegenerator}{
	name={Codegenerator},
	description={
		Ein \emph{Codegenerator} ist ein Programm, welches aus einer höhersprachigen Spezifikation (m. a. W.: auf einem höheren Abstraktionslevel als die zur Implementierung verwendete Programmiersprache), einer Software oder eines Teilaspektes die Implementierung erzeugt (nach \cite{czarnecki2000generative})
	}
}

\newglossaryentry{Parsing}{
	name=Parsing,
	description={
		Parsing oder auch \emph{Syntaxanalyse} erzeugt aus einer Zeichenkette einen \gls{AST} aufgrund der Regeln einer Grammatik. Der Aufbau der Zeichenkette wird also nach den Regeln der Grammatik analysiert und die einzelnen Elemente in einen \gls{AST} überführt.
	}
}

\newglossaryentry{REST}{
	name=\textsc{Rest}, 
	description={
		\emph{Representational State Transfer} (deutsch: \enquote{Gegenständlicher Zustandstransfer}) ist ein Softwarearchitekturstil für Webanwendungen, welcher von Roy Fielding in seiner Dissertation \cite{fieldingDissertation} beschrieben wurde. Die Daten liegen dabei in eindeutig addressierbaren \emph{resources} vor. Die Interaktion basiert auf dem Austausch von \emph{representations} -- also ein Dokument was den aktuellen oder gewünschten Zustand einer resource beschreibt.
		Beispiel-URL für das Item \emph{84} aus dem Warenkorb \emph{42}:\\
		\texttt{http://api.spreadshirt.net/api/v1/baskets/84/item/42}
	}
}

\newglossaryentry{RESTful}{
	name=\textsc{Rest}ful,
	description={
		Als \emph{RESTful} bezeichnet man einen Webservice der den Prinzipien von REST entspricht
	},
	see=REST
}

\newglossaryentry{API}{
	name=\textsc{Api}, 
	description={
		\emph{Application Programming Interface} (deutsch: \enquote{Schnittstelle zur Anwendungsprogrammierung}) spezifiziert, wie Softwarekomponenten über diese Schnittstelle miteinander interagieren können
	},
	plural=\textsc{Api}s
}

\newglossaryentry{XML}{
	name=\textsc{Xml},
	description={
		Die \emph{Extensible Markup Language}, kurz \textsc{Xml}, ist eine Auszeichnungssprache (\enquote{Markup Language}), die eine Menge von Regeln beschreibt um Dokumente in einem mensch- und maschinenlesbaren Format zu kodieren \cite{XML10Specification}
		%\emph{Extensible Markup Language} (deutsch: \enquote{erweiterbare Auszeichnungssprache}) ist ein mensch- und maschinenlesbares Format für Codierung und Austausch von Daten, \printhref{http://www.w3.org/TR/REC-xml}{spezifiziert vom W3C}
	}
}

\newglossaryentry{JSON}{
	name=\textsc{Json},
	description={
		\emph{JavaScript Object Notation}, kurz \textsc{Json}, ist ein leichtgewichtiges, textbasiertes und sprachunbhängiges Datenaustauschformat. Es ist von JavaScript abgeleitet und definiert eine kleine Menge von Formatierungsregeln für die transportable Darstellung (Serialisierung) von strukturierten Daten (nach \cite{JSONRFC})
		%\emph{JavaScript Object Notation} ist ein Mensch- und Maschinenlesbares Format zu Codierung und Austausch von Daten. Es bietet im Gegensatz zu XML keine Erweiterbarkeit und Unterstützung für Namesräume, ist aber kompakter und einfacher zu parsen
	}, 
	see=XML
}

\newglossaryentry{XSD}{
	name=\textsc{Xsd},
	description={
		\emph{XML Schema Description}, auch nur \emph{XML Schema} ist eine Schemabeschreibungssprache und enthält Regeln für den Aufbau und zum Validieren einer XML-Datei. Die Beschreibung ist selbst wieder eine gültige XML-Datei
	},
	see=XML
}

%\newglossaryentry{RelaxNG}{
%	name=RelaxNG,
%	description={
%		\emph{Regular Language Description for XML New Generation} ist ebenso wie \emph{XSD} eine Schemabeschreibungssprache, bietet aber zwei Syntaxformen, eine XML basierte und eine kompaktere eigene Syntax
%	}, 
%	see=XSD
%

\newglossaryentry{WADL}{
	name=\textsc{Wadl},
	description={
		\emph{Web Application Description Language} ist eine maschinenlesbare Beschreibung einer HTTP-basierten Webanwendung
	},
	see=XML
}

\newglossaryentry{Polyglot}{
	name=Polyglot,
	description={
		\emph{mehrsprachig}
	}
}

\newglossaryentry{Metaprogramming}{
	name=Metaprogramming,
	description={
		beschreibt das erstellen von Programmen welche sich selbst, oder andere Programme, modifizieren oder die einen Teil des Kompilierungsschrittes übernehmen (beispielsweise der C-Präprozessor)
	}
}

\newglossaryentry{DSL}{
	name=\textsc{Dsl},
	description={
		\emph{Domain Specific Language} (deutsch: \enquote{Domänenspezifische Sprache}) ist eine Programmiersprache die nur auf eine bestimmte Domäne oder auch Problembereich optimiert ist
	}
}

\newglossaryentry{template-engine}{
	name=Template-Engine,
	description={
		Eine \emph{Template-Engine} ersetzt markierte Bereiche in einer Template-Datei (i. Allg. Textdateien) nach vorgegebenen Regeln
	}
}

\newglossaryentry{MIME}{
	name=\textsc{Mime},
	description={
		\emph{Multipurpose Internet Mail Extensions} dienen zu Deklaration von Inhalten (Typ des Inhalts) in verschiedenen Internetprotokollen
	}
}

\newglossaryentry{DTD}{
	name=\textsc{Dtd},
	description={
		\emph{Document Type Definition}, manchmal auch \emph{Data Type Definition} ist eine Menge von Angaben, die einen Dokumenttyp beschreiben. Es werden konkret Element- und Attributtypen, Entitäten und deren Struktur beschrieben. Die bekanntesten Schemasprachen für XML-Dokumente sind XSD und RelaxNG
	},
	see=XSD
}

% http://en.wikipedia.org/wiki/Model-driven_architecture
\newglossaryentry{MDA}{
	name=\textsc{Mda},
	description={
		\emph{Model Driven Architecture} ist ein modell-getriebener Softwareentwicklungsansatz. Das zu modellierende System wird hierbei durch ein plattformunabhängiges Modell beschrieben mittels einer \gls{DSL} beschrieben. Dieses Modell wird dann durch einen Generator in ein plattformspezifisches Modell, meist in einer \gls{GPL} übersetzt
	}
}

% Wikipedia
% \newglossaryentry{MDSD}{
% 	name=\textsc{Mdsd},
% 	description={
% 		\emph{Model Driven Software Development}, auch \emph{Model Driven Engineering} ist eine Softwareentwicklungsmethode welche ihren Fokus auf das erzeugen und nutzen von Domänen-Modellen, anstelle der algorithmischen Konzepte, legt
%  	}	
% }

% \newglossaryentry{MDE}{
% 	name=\textsc{Mde},
% 	description={
% 		\emph{Model Driven Engineering}
% 	},
% 	see=MDSD
% }

\newglossaryentry{AST}{
	name=Abstract Syntax Tree,
	description={
		Ein \emph{Abstrakter Syntaxbaum} ist die Baumdarstellung einer abstrakten Syntaktischen Struktur von Quellcode einer Programmiersprache. Jeder Knoten des Baumes kennzeichnet ein Konstrukt des Quellcodes. Der \emph{AST} stellt für gewöhnlich nicht alle Details des Quelltextes dar, beispielsweise formatierende Element wie etwa Klammern werden häufig weggelassen
	}
}

\newglossaryentry{GPL}{
	name=General Purpose Language,
	description={
		Eine \emph{General Purpose Language} bezeichnet eine Programmiersprache welche für den Einsatz in den verschiedensten Anwendungsbereichen verwendet kann, im Gegensatz zu einer \gls{DSL}, welche nur auf einen speziellen Bereich beschränkt ist
	}
}

\newglossaryentry{closure}{
	plural=Closures,
	name=Closure,
	description={
		Eine \emph{Closure} ist eine Funktion, welche die besondere Eigenschaft besitzt auf Variablen aus ihrem Entstehungskontext zugreifen zu können. Die Funktion wird meist in einer Variablen gespeichert um den Zugriff darauf zu sichern
	}
}