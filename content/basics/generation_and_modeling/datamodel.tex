\section{Datenmodell}
\label{section:datamodel}

% todo: Spezifikation oder domänenspezifisches Modell?
Das Datenmodell enthält die Informationen der Spezifikation und dient als Eingabe für den Generator, es ist somit die \emph{Basis der Codegenerierung}. \citeauthor{rfc3198} definieren den Begriff in \cite{rfc3198} folgenderweise\footnote{eigene Übersetzung}:

\thesisDefinition{Datenmodell}{
    Ein Datenmodell ist im Grunde die Darstellung eines Informationsmodells unter Berücksichtigung einer Menge von Mechanismen für die Darstellung, Organisierung, Speicherung und Bearbeitung von Daten.
    Das Modell besteht aus einer Sammlung von \ldots
    \begin{compactitem}
        \item{Datenstrukturen, wie Listen, Tabellen, Relationen etc.}
        \item{Operationen die auf die Strukturen angewendet werden können, wie Abfrage, Aktualisierung, ...}
        \item{Integritätsbedingungen die gültige Zustände (Menge von Werten) odder Zustandsänderungen (Operationen auf Werten) definieren.}
    \end{compactitem}
}

Bei dieser Definition wird der Begriff \emph{Informationsmodell} genutzt, er beschreibt die Informationen die im Datenmodell abgebildet werden sollen ohne Berücksichtigung softwaretechnischer Aspekte. Das Informationsmodell stellt somit die \enquote{natürlichen Daten} dar.

Einteilung der Datenmodellschemas nach ANSI:
\begin{description}
    \item[Konzeptuelles Schema]
        beschreibt die Semantiken der Domäne und legt den Gültigkeitsbereich des Datenmodells fest.
    \item[Logisches Schema]
        dient der Strukturbeschreibung des Modells. Wird oft durch Verfeinerung aus dem Konzeptuellen Schema entwickelt.
    \item[Physisches Schema]
        definiert die Form der Speicherung der Daten auf einem Physischen Datenträger.
\end{description}

% konkretes Modell
Das konkrete Modell für die Spreadshirt-API, setzt sich aus deren Beschreibung im \gls{WADL} und \gls{XSD} zusammen. Die Schnittpunkte beider Beschreibungen finden sich in der Angabe der Methodenparameter- und Rückgabewerte der \gls{WADL}-Datei, wie das folgende Listing zeigt.

\begin{lstlisting}[
    language=XML,
    label=lst:wadlintersection,
    caption=HTTP-GET-Methode zur Anzeige von Produkttypen eines Users (gekürzt)
    ]
<resource path="users/{userId}/productTypes">
    ...
    <method name="GET">
        ...
        <request>
            ...
            <param xmlns:xsd="http://www.w3.org/2001/XMLSchema"//@\ding{204}@// name="sessionId" style="query" type="xsd:string" //@\ding{202}@//>
                <doc>The security session id, e.g. 123.</doc>
            </param>
            ...
        </request>
        <response>
            <representation xmlns:sns="http://api.spreadshirt.net"//@\ding{205}@// element="sns:productTypes" //@\ding{203}@// status="200" mediaType="application/xml">
                <doc title="Success"/>
            </representation>
            <fault status="500" mediaType="text/plain">
                <doc title="Internal Server Error"/>
            </fault>
            ...
        </response>
    </method>
</resource>
\end{lstlisting}

\Cref{lst:wadlintersection} zeigt einen Ausschnitt aus der Beschreibung der API-Methode zum Erhalt der \emph{Produkttypen} eines bestimmten \emph{Users}. Punkt \ding{202} und \ding{203} sind Typangaben, wobei ersteres einen Parameter- und letzteres ein Rückgabetyp ist. Die jeweiligen Namensräume der Typen werden unter \ding{204} und \ding{205} angegeben.

% todo: Datenmodell aus der Spezifikation erstellen, bei REST Vereinigung der WADL und Schemata in ein Datenmodell. Erkennen von Semantik in Spezifikation oder Datenmodell, beispielweise auflösen von Abhängigkeiten. Listing zeigt Schnittpunkte zwischen beiden Modellen. Gemeinsames Modell in Form eines Baumes (AST).

\subsection{Abstract Syntax Tree (AST)}
\label{sec:ast}

\thesisDefinition{Abstract Syntax Tree -- Grune}{
Der abstrakte Syntaxbaum (engl. \enquote{Abstract Syntax Tree}) stellt die verschiedenen Teile eines Programmtextes aus Sicht der Grammatik, dar %\cite[][S. 9 ff.]{gruneCompiler}.
}

\thesisDefinition{Abstract Syntax Tree -- Aho}{
Ein Abstrakter Syntaxbaum ist die Darstellung eines Ausdrucks, wo jeder Knoten einen \emph{Operator} und dessen Kindknoten die \emph{Operanden} repräsentieren.
%Jeder Knoten eines \emph{Abstrakten Syntax Baumes} für einen Ausdruck, repräsentiert einen \emph{Operator} und dessen Kindknoten stellen die  \emph{Operanden} dar. 
%Im Allgemeinen kann für jedes Programmierkonstrukt ein Operator erzeugt werden, dessen semantisch bedeutsamen Komponenten dann als Operanden gehandhabt werden (nach \cite[][S. 69]{ahoCompiler}).
}

Er ist das Endprodukt eines Parsingschrittes des Quelltextes, im Gegensatz zum \emph{konkreten Syntaxbaum} (auch \emph{Parse Tree}) enthält der \emph{AST} keine Formatierungsspezifische Syntax (bspw. Klammern). 

\begin{figure}[htb]
    \centering
    %\resizebox{\textwidth}{!}{
        \centering
        \begin{tikzpicture}
            \Tree 
                [ .gcd 
                    [ .= 
                        [ .if 
                            [ .== 
                                [ .b ] 
                                [ .0 ]
                            ]
                            [ .a ]
                        ] 
                        [ .else 
                            [ .gcd
                                [ .b ]
                                [ .\% 
                                    [ .a ]
                                    [ .b ]
                                ]
                            ]
                        ]
                    ]
                ]
        \end{tikzpicture}        
    %}
    \caption{Beispiel AST für den rekursiven euklidischen Algorithmus}
    \label{fig:ast}   
\end{figure}

Ein \emph{AST} bildet auch die Grundstruktur des Datenmodells für den Generator. 

\subsection{PHP Beispiele}

\begin{lstlisting}[
    language=PHP,
    caption=Abfrage der Designs eines Users per HTTP-GET
    ]
<?php

?>
\end{lstlisting}

\input{content/basics/generation_and_modeling/conceptual_model}

\input{content/basics/generation_and_modeling/dsl}