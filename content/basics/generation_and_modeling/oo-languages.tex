\section{Objektorientierte Sprachen}
\label{sec:oo_languages}

Ziel des Generators ist die Erzeugung von Code in einer Objektorientierten\footnote{nachfolgend nur noch OO} Sprache. Aus diesem Grund werden die elementaren Konzepte solcher Sprachen in diesem Abschnitt näher erläutert, sowie die Besonderheiten der Generatorzielsprache (PHP) beschrieben.

Im Gegensatz zu \emph{Prozeduralen Sprachen}\footnote{Zu den Prozeduralen Sprachen zählt bspw. C und Pascal}, in denen ein Programm eine Liste von Funktionen ist, wird dieses im OO-Programmierparadigma aus der Interaktion von \emph{Objekten} gebildet. 

% OO gehört zu den Imperativen Sprachen, Prozedurale Programmierung Submenge der Objekt-orientierten Programmierung? 
%Ein Programm in einer OO-Sprache welches nur aus einer Klasse besteht, welche nur öffentliche Methoden besitzt kann direkt auf eine Prozedruale Sprache  abgebildet werden.

\subsection{Elemente}
\label{sec:elements_of_object_oriented_languages}

% rekursiv definieren, Objekt enthält methoden und felder, felder und methoden access modifier ...
Die Beschreibung der Elemente einer OO-Sprache basiert auf \cite{oopSkript2012}.

\begin{description}
    \item[Objekte] 
        Elementare logische Einheit, kapselt Variablen und \emph{Methoden} (Kapselung) und schützt private Daten vor äußerem Zugriff (Data-Hiding). Der Zugriff auf die Elemente des Objektes wird über \emph{Access Modifier} geregelt. Bilden einen Namensraum und schützen davor das Änderungen an privaten Daten sich auf andere Objekte auswirken.
    % Identität, Zustand und Verhalten
    \item[Klassen] 
        Klassen beschreiben die Variablen und Methoden für Objekte die aus ihnen erzeugt werden. Ein Objekt ist eine \emph{Instanz} einer Klasse. Eine Klasse kann ein aus ihr erzeugtes Objekt mit bestimmten Vorgabewerten initialisieren. Objekte einer Klasse werden erzeugt oder auch instanziiert durch den Aufruf der Konstruktormethode der Klasse.
        Die meisten OO-Sprachen bieten Möglichkeiten der Vererbung, d.h. das Klassen gewisse Eigenschaften und Methoden von einer Klasse \enquote{erben} können. Weiterhin können Klassen auch abstrakt sein, also die in ihnen enthaltenen Klassen und Methoden sind nur Bezeichner aber besitzen keine Definition. Diese müssen dann von den klassen definiert werden die diese Abstrakten Klassen \emph{implementieren}.
    \item[Methoden]
        Methoden sind die \emph{Funktionen} des Objektes, sie beschreiben sein \emph{Verhalten}.
    \item[Felder]
        Felder enthalten die Daten des Objektes. Ihr Inhalt repräsentiert den \emph{Zustand} des Objektes.
    \item[Access Modifier]    
        Access Modifier regeln den Zugriff auf die Elemente eines Objektes, die gebräuchlichsten sind hierbei \texttt{public, private} und \texttt{protected}, durch deren Verwendung wird die Kapselung von Daten erreicht. Welche Arten der Zugriffskontrolle letztendlich vorhanden sind ist abhängig von der verwendeten Programmiersprache.
    \item[Namensräume]
        Namensräume erlauben die Verwendung von gleichen Bezeichnern in unterschiedlichen Namensräumen. Wie im Punkt Objekte erwähnt, bilden diese bspw. einen eigenen Namensraum. Der Zugriff auf ein Element eines Objektes erfolgt über seinen Namensraum, will man auf das Element \texttt{bar} des Objektes \texttt{foo} zugreifen, geschieht dies z.B. in PHP folgendermaßen: \texttt{foo->bar}.
        % todo: packages, namespace (section 7 of the java language specification)
        % PHP als Beispiel
\end{description}

\subsection{Typsystem}
\label{sec:typesystem}

\citeauthor{voelterDSLEngineering} definieren den Begriff \enquote{Typsystem} auf \cite[][S. 253]{voelterDSLEngineering} so (eigene Übersetzung):

\thesisDefinition{Typsystem}{
    Ein Typsystem ordnet den Programmelementen Typen zu und prüft die Konformität dieser Typen nach bestimmten vordefinierten Regeln.
}

Der \emph{Typ} ist eine Eigenschaft eines Programmkonstruktes, ein solches Konstrukt ist z.B. eine Konstante, Variable, Methode.

Es wird zwischen zwei grundlegenden Formen von Typsystemen unterschieden, \emph{statisch} und \emph{dynamisch}. Das Unterscheidungskriterium ist der Zeitpunkt der Typprüfung. Dynamische Typsysteme prüfen erst während der Laufzeit des Programms, bei statischen Typsystemen hingegen übernimmt der \emph{Compiler} diese Aufgabe. Ein statisches Typsystem erfordert in den meisten Fällen die explizite Angabe des Typs durch den Programmierer. Programmiersprachen mit statischen Typsystemen welche \emph{Typinferenz} bieten, können oft anhand des Wertes eines Konstruktes seinen Typ erkennen und ersparen in diesen Fällen dem Programmierer dessen explizite Angabe.

\subsection{PHP}
\label{sec:php}

PHP ist eine \gls{GPL} die aber vorwiegend auf die Entwicklung von serverseitigen Webapplikationen ausgerichtet ist. PHP Skripte können in HTML-Dateien eingebettet werden, welche der Server bei einer Client-Anfrage verarbeitet, die PHP Elemente durch deren Ausgabe ersetzt und dem Client zurücksendet. Die Sprache gehört somit zu den \emph{Server-Side Scripting Languages}. Die Verwendung ist aber nicht auf diesen Bereich beschränkt, denn PHP Anweisungen müssen nicht in HTML eingebettet sein sondern können auch unabhängig davon, als eigene Datei, ausgeführt werden.
Im Gegensatz zu \emph{Java} ist PHP nicht statisch typisiert und muss zur Ausführung auch nicht kompiliert werden. PHP ist \emph{dynamisch typisiert} und wird von einem Interpreter --- dem namensgebenden \emph{Hypertext Preprocessor} --- ausgeführt.
Es werden mehrere Programmierparadigmen unterstützt, seit Version 5.0 neben Imperativer- auch Objektorientierte Programmierung. Version 5.3 fügte die Unterstützung von \glspl{closure} hinzu.

\begin{lstlisting}[language=php, caption=Durch den Generator erzeugte BatchDTO Datenklasse der Spreadshirt-API als Beispiel für eine PHP-Datei]
<?php //@\ding{202}@//
   require_once('Dto.php'); //@\ding{203}@//
   require_once('OperationDTO.php'); //@\ding{203}@//

   class BatchDTO
   {
      private $operations = array(); // operationDTO 

      function __construct(operationDTO //@\ding{204}@// $operations) 
      {
         $this->operations = $operations;
      }

      public function getOperations()
      {
         return $operations = $this->operations;
      }

      public function setOperations(operationDTO $operations)
      {
         $this->operations = $operations;
      }

      public function toJSON()
      {
         $json = json_decode(/* BatchDTO */ $this);
         return $json;
      }

      ...

      public static //@\ding{205}@// function fromXML(SimpleXMLElement $xml)
      {
         $operations = OperationDTO::fromXML(/* SimpleXMLElement */ $xml->operations);
         $BatchDTO =  new BatchDTO(/* operationDTO */ $operations);
         return $BatchDTO;
      }

      ...
   }

?> //@\ding{202}@//
\end{lstlisting}

\begin{compactitem}
    \item[\ding{202}] Start- und Endtags eines PHPFiles, wobei letzteres optional ist. Deren Funktion ist die Abgrenzung vom umliegenden Markup, bspw. wenn der PHP-Code in eine HTML Datei eingebettet ist.
    \item[\ding{203}] PHP unterstützt das importieren von Quellcodefiles anhand verschiedener Befehle, in diesem Fall \texttt{require\_once}.
    \item[\ding{204}] Nur in der Argumentliste einer Methodendefinition sind Typangaben erlaubt, solange der Typ kein primitiver ist, d.h. den sprachinternen primitiven Datentypen wie bspw. String oder Integer entspricht. 
    \item[\ding{205}] Statische Methoden, können ohne Instanz der umgebenden Klasse aufgerufen werden, sind ebenfalls ünterstützt.
\end{compactitem}
