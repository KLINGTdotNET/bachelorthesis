\section{Generatorsysteme}
\label{sec:generatorsystems}

%Generative Programming p. 333
Ein \emph{Codegenerator} ist ein Programm, welches aus der höhersprachigen Spezifikation\footnote{mit anderen Worten: auf einem höheren Abstraktionslevel als die zur Implementierung verwendete Programmiersprache} einer Software oder eines Teilaspektes, die Implementierung erzeugt (nach \cite{czarnecki2000generative}).

% todo: folgende Liste entfernen?
Generatoren widmen sich drei wichtigen Problemen\cite{czarnecki2000generative}:
\begin{description}[style=nextline]
    \item[Relevanz von Systembeschreibungen erhöhen] Eine Systembeschreibung sollte direkt und explizit die Anforderungen bestimmen und mit der Sprache der Problemdomäne formuliert sein.
    \item[Erzeugung einer effizienten Implementierung] Die größte Herausforderung bei der Erstellung eines Generators liegt in der Abbildung von der Spezifikation zur Implementierung, da es meist keine direkte Übereinstimmung zwischen beiden Konzepten gibt.
    \item[\enquote{Library scaling problem}] Nur die durch die Spezifikation benötigten Methoden generieren.
\end{description}

% todo: Satz ändern, quasi nur Übersetzung
Der Begriff \enquote{Generator} ist sehr allgemein und wird für verschiedene Technologien verwendet, wie \emph{Compiler}, \emph{Präprozessoren}, Metafunktionen (Template-Metaprogramming in C++), Code-Transformatoren und natürlich Code-Generatoren.

\subsection{Aufgaben eines Generators}
\begin{compactenum}
    \item Validieren der Spezifikation
    \item Spezifikation durch Vorgabewerte vervollständigen
    \item Optimierungen vornehmen
    \item Implementierung erzeugen
\end{compactenum}

Generatoren die eine Spezifikation in Textform erwarten, müssen einen \emph{Analyse}-Schritt (parsing) durchführen um die Spezifikation in die interne Darstellung zu überführen, z.B. ein \emph{Abstrakter Syntaxbaum} bei einem Compiler. Daraus lässt sich schließen, dass der Grad der Automatisierung durch Codegenerierung abhängig von dem Informationsgehalt der Spezifikation ist.

\subsection{Konzeptuelles Modell}

Ein Modell bildet die Funktionen und Beziehungen eines Bereiches der Wirklichkeit ab.
Ein solches Modell, beispielsweise in Form einer \gls{WADL}-Datei zur Beschreibung einer Web-API, dient als Eingabe für einen Generator. Außerdem ist es der Ausgangspunkt in der modell-getriebenen Softwareentwicklung (\gls{MDSD}) oder -architektur (\gls{MDA}).

\begin{figure}[tb]
    \begin{center}
    %\resizebox{\textwidth}{!}{
        \begin{tikzpicture}[
            node distance=12mm and 8mm,
            every node/.style={font=\scriptsize}
            ]
            \node(model)[greyBlock]{Modell};
            \node(generator)[greyBlock, right=of model]{Codegenerator};
            \node(sourcecode)[greyBlock, double copy shadow, right=of generator]{Quellcode};
            \node(templates)[greyBlock, double copy shadow, above=of generator]{Templates};
            \node(infrastructurecode)[greyBlock, double copy shadow, below=of generator]{Infrastrukturcode};     

            \path [arrow, ->] (model) -- (generator);
            \path [arrow, ->] (templates) -- (generator);
            \path [arrow, ->] (infrastructurecode) -- (generator);
            \path [arrow, ->] (generator) -- (sourcecode);
        \end{tikzpicture}   
    %}
    \end{center}
    \caption{Simples Generatorsystem}
    \label{fig:generatorsystem}
\end{figure}


% todo: überarbeiten und Überleitung herstellen
\subsection{Transformationen}

% p. 344 Generative Programming
Eine Transformation ist eine automatisierte und semantisch korrekte Modifikation einer Programmdarstellung %-beschreibung
(Quelltext, Abstrakte Beschreibung, UML, \ldots).

\subsubsection{Verfeinerung}

\begin{description}[style=nextline]
    \item[Dekomposition\footnote{Auflösung}]
        Auflösen der Konzepte der höheren Abstraktions- in der niedrigeren Abstraktionsebene.
    \item[Wahl der Darstellung] 
        Auswahl eines passenden Datentyps.
    \item[Wahl der Algorithmen]
        Abhängig vom Datentyp und den \emph{nicht-funktionalen Anforderungen} wie z.B. Performanzkriterien, Speicherplatzbeschränkung oder Antwortzeit
    \item[Spezialisierung]
        Anpassung allgemein formulierter abstrakter Beschreibung an Details der Implementierung
    \item[Konkretisierung]
        Hinzufügen von Implementationsdetails
\end{description}

\subsubsection{Optimierung durch den Generator}

\begin{description}[style=nextline]
\item[Inlining]
    Ein Symbol durch seine Definition ersetzen, anstelle eines Funktionsaufrufes, die Deklaration der Funktion selbst einfügen
\item[Constant folding]
    Auswertung von Ausdrücken deren Operanden während der \emph{compile time} bekannt sind.
\item[Data caching]
    Anstatt mehrfach denselben Ausdruck auszuwerten, das Ergebnis einmal berechnen und darauf an anderer Stelle referenzieren
\item[Loop fusion]
    \ldots
\item[Loop unrolling]
    Die Schleife durch $n$-mal den Inhalt ersetzen, wobei $n$ die Anzahl der Iterationen ist
\item[Parallelization]
    %todo: wann moeglich
\item[Code motion]
    Invariante\footnote{unveränderliche} Codebereiche aus dem Schleifenkörper herausnehmen
\item[Dead-code elimination]
    Entfernen von ungenutzten Variablen und unerreichbaren Codebereichen
\item[Partial evaluation]
    \ldots
\item[Finite differencing]     
\end{description}

% global optimizations?

Viele dieser Optimierungen werden vom Compiler durchgeführt, deren Effektivität steigt aber mit dem Abstraktionslevel. Deshalb ist es effektiver diese auch durch den Generator durchführen zu lassen, da dieser auch anhand domänen-spezifischen Wissens optimieren kann (\emph{domain-specific optimization}).