./content/introduction/spreadshirt.tex:16:Für die Spreadshirt-API können Kunden eigene Anwendungen schreiben, bspw. \citetitle{zufallsshirt} \cite{zufallsshirt} oder \citetitle{soundslikecotton} \cite{soundslikecotton}.
./content/introduction/spreadshirt.tex:20:Die \emph{sprd.net AG} zu der auch der Leipziger Hauptsitz gehört beschäftigt derzeit (Juni 2013) 178 Mitarbeiter, davon 29 in der IT.
./content/introduction/problem_statement.tex:4:Es ist ein Codegenerator zu erstellen, der aus der abstrakten Beschreibung der \gls{RESTful} Spreadshirt \gls{API} eine Client-Bibliothek erstellt. 
./content/introduction/problem_statement.tex:7:Für das Bibliotheksdesign ist eine \gls{DSL} (Domain-Specific Language) zu realisieren, mit dem Ziel die Nutzung der \gls{API} zu vereinfachen. 
./content/introduction/introduction.tex:15:Das Ziel dieser Arbeit ist die Erstellung eines Codegenerators, der aus der abstrakten Beschreibung der Spreadshirt-\gls{API} eine Client-Bibliothek erstellt.
./content/introduction/introduction.tex:18:Für das Bibliotheksdesign ist eine \gls{DSL} (Domain-Specific Language) zu realisieren, mit dem Ziel die Nutzung der \gls{API} zu vereinfachen. 
./content/introduction/introduction.tex:20:Als Programmiersprache für den Generator wird \emph{Java} verwendet, \emph{PHP} ist die Zielsprache der Bibliothek.
./content/evaluation/evaluation.tex:10:\section{PHP-Zielsprachenmodell}
./content/basics/web_services/xml_schema/xsd.tex:1:\subsection{XML Schema Description (XSD)}
./content/basics/web_services/xml_schema/xsd.tex:4:\emph{XML Schema Description} ist ein stark erweiterte Nachfolger der \emph{DTD} (Document Type Definition), derzeit spezifiert in Version 1.1 \cite{XMLSchema11Specification}. 
./content/basics/web_services/xml_schema/xsd.tex:5:Die Syntax von \emph{XSD} ist XML, damit ist die Schemabeschreibung ebenfalls ein gültiges XML-Dokument. Als Dateiendung wird üblicherweise \texttt{.xsd} verwendet.
./content/basics/web_services/xml_schema/xsd.tex:7:Die Hauptmerkmale von XSD sind nach \cite[Kapitel 3.2][]{taxonomyXMLSchema}
./content/basics/web_services/xml_schema/xsd.tex:20:    language=XML,
./content/basics/web_services/xml_schema/xsd.tex:21:    caption=Beginn der XSD-Datei für die Spreadshirt-API,
./content/basics/web_services/xml_schema/xsd.tex:24:<?xml version="1.0" encoding="UTF-8" standalone="yes"?> //@\ding{202}@//
./content/basics/web_services/xml_schema/xsd.tex:25:<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  targetNamespace="http://api.spreadshirt.net" version="1.0" elementFormDefault="qualified"> //@\ding{203}@//
./content/basics/web_services/xml_schema/xsd.tex:30:Eine XSD-Datei beginnt wie jede XML-Datei mit der XML-Deklaration \ding{202}.
./content/basics/web_services/xml_schema/xsd.tex:33:Das Attribut \emph{xmlns:xs= "http://www.w3.org/2001/XMLSchema"} führt den Namespace-Prefix \emph{xs} ein und gibt außerdem an, dass die Elemente und vordefinierten Datentypen (siehe \cref{fig:xsddatatypes}) aus dem Namensraum \emph{http://www.w3.org/2001/XMLSchema} verwendet werden. Durch das Attribut \emph{targetNamespace} wird der Namensraum der Elemente festgelegt, die in dieser Schemadefinition definiert werden. \emph{Version} gibt die XSD-Version an.
./content/basics/web_services/xml_schema/xsd.tex:36:Externe Schemadefinitionen lassen sich unter Angabe des Namensraumes und einer \gls{URI} zu der XSD-Datei einbinden \ding{204}.
./content/basics/web_services/xml_schema/xsd.tex:38:XML Schema Description erlaubt die Definition von simplen Typen (\enquote{SimpleType}) und Typen mit strukturiertem Inhalt (\enquote{ComplexType}).
./content/basics/web_services/xml_schema/xsd.tex:41:    language=XML,
./content/basics/web_services/xml_schema/xsd.tex:42:    caption=Beispiel für einen SimpleType anhand des Type \enquote{unit} der Spreadshirt-API,
./content/basics/web_services/xml_schema/xsd.tex:55:Durch einen SimpleType definierte Listen sind durch Leerzeichen separierte Strings, sie werden meist für den Wert eines Attributes einer XML-Datei verwendet. 
./content/basics/web_services/xml_schema/xsd.tex:58:    language=XML,
./content/basics/web_services/xml_schema/xsd.tex:68:    language=XML,
./content/basics/web_services/xml_schema/xsd.tex:78:    language=XML, 
./content/basics/web_services/xml_schema/xsd.tex:79:    caption=Beispiel für eine Schemabeschreibung mit XSD anhand des \enquote{abstractList}-Typs der Spreadshirt-API,
./content/basics/web_services/xml_schema/xsd.tex:99:Das \emph{ComplexType}-Tag \ding{202} umschließt die Definiton des strukturierten Typs. XML Schema Description erlaubt das definieren von abstrakten Typen, nur Ableitungen davon dürfen als Instanzen in einem Dokument auftreten. Abgeleitete Typen dürfen dabei den abstrakten Typ \emph{erweitern} o. \emph{einschränken} (\enquote{derivation by extension/restriction}).
./content/basics/web_services/xml_schema/xsd.tex:105:Elemente einer XML-Datei werden durch das gleichnamige \emph{Element} \ding{205} im XSD definiert. Ein Element benötigt die Angabe eines Namens und Typs. Die Angabe des Typs kann dabei als Referenz auf die Typdefinition \ding{207} oder als Definition unterhalb des Element-Tags erfolgen \ding{206}.
./content/basics/web_services/xml_schema/xsd.tex:107:Attribute eines XML-Tags werden durch das \emph{Attribute}-Element definiert. Dies geschieht durch Angabe von Name und Typ \ding{208} oder durch eine Referenz auf eine Attributdefinition \ding{207}.
./content/basics/web_services/xml_schema/xsd.tex:112:    \underbrace{\texttt{xmlns:tns}}_{\tiny \text{XML-Namespace:Namensraumbezeichner}}\texttt{=}\underbrace{\texttt{"http://api.spreadshirt.net"}}_{\tiny \text{Konkreter Namensraum}}
./content/basics/web_services/xml_schema/xsd.tex:159:    \caption{vordefinierte XSD Datentypen nach \cite{XMLSchema11Specification} Kapitel 3}
./content/basics/web_services/xml_schema/relax-ng.tex:1:\subsection{RelaxNG}
./content/basics/web_services/xml_schema/relax-ng.tex:5:Ebenso wie XSD (siehe \cref{sec:xsd}) ist die \emph{Regular Language Description for XML New Generation} eine XML-Schemasprache zur Definition der Struktur von XML-Dokumenten. 
./content/basics/web_services/xml_schema/relax-ng.tex:6:Schemas werden in \emph{RelaxNG} durch XML-Syntax oder eine eigene, kompaktere nicht-XML Syntax formuliert. Ebenso wie bei \emph{XML Schema} werden Namespaces unterstützt. RelaxNG Schemabeschreibungen verwenden meist \texttt{.rng} als Dateiendung.
./content/basics/web_services/xml_schema/relax-ng.tex:8:Unterschiede zu XML Schema:
./content/basics/web_services/xml_schema/relax-ng.tex:11:    \item kompaktere nicht-XML Syntax
./content/basics/web_services/xml_schema/relax-ng.tex:12:    \item \emph{nichtdeterministisches} oder auch \emph{mehrdeutiges} Inhaltsmodell \cite[Kapitel 16]{RelaxNGVlist}    
./content/basics/web_services/xml_schema/relax-ng.tex:17:    language=XML, 
./content/basics/web_services/xml_schema/relax-ng.tex:18:    caption=Minimalbeispiel für eine Schemadefinition in RelaxNG, 
./content/basics/web_services/xml_schema/relax-ng.tex:19:    label=minimalRelaxNG]
./content/basics/web_services/xml_schema/xml_schema.tex:2:\section{XML Schemabeschreibungssprachen (XML Schema)}
./content/basics/web_services/xml_schema/xml_schema.tex:5:\emph{XML Schema} bezeichnet XML-basierte Sprachen mit denen sich Elemente, Attribute und Aufbau einer Menge von XML-Dokumenten --- die dem Schema entsprechen --- beschreiben lassen. 
./content/basics/web_services/xml_schema/xml_schema.tex:6:Ein XML-Dokument wird als \emph{valid} gegenüber einem Schema bezeichnet, falls die Elemente und Attribute dieses Dokumentes die Bedingungen des Schemas erfüllen \cite{taxonomyXMLSchema}.
./content/basics/web_services/xml_schema/xml_schema.tex:7:Neben XSD und RelaxNG (siehe \cref{sec:relaxng}) existieren noch weitere Schemasprachen, die hier aber aufgrund ihrer geringen Relevanz nicht behandelt werden. Die beiden hier behandelten Schemasprachen bieten den Vorteil selbst XML-Dokumente zu sein, somit können sie durch herkömmliche XML-Tools bearbeitet werden.
./content/basics/web_services/document_description_formats.tex:4:In diesem Abschnitt werden die Dokumentbeschreibungsformate \gls{XML} und \gls{JSON}, der Spreadshirt-API behandelt. Außerdem wird die Schemabeschreibungssprache \emph{XML Schema Description} eingeführt.
./content/basics/web_services/xml.tex:1:\subsection{XML}
./content/basics/web_services/xml.tex:4:\thesisDefinition{XML}{
./content/basics/web_services/xml.tex:5:Die \emph{Extensible Markup Language}, kurz \gls{XML}, ist eine Auszeichnungssprache (\enquote{Markup Language}) die eine Menge von Regeln beschreibt um Dokumente in einem mensch- und maschinen lesbaren Format zu kodieren \cite{XML10Specification}.
./content/basics/web_services/xml.tex:8:Obwohl das Design von XML auf Dokumente ausgerichtet ist, wird es häufig für die Darstellung von beliebigen Daten benutzt \cite{wiki:xml}, z.B. um diese für die Übertragung zu serialisieren.
./content/basics/web_services/xml.tex:11:        language=XML, 
./content/basics/web_services/xml.tex:12:        caption=Die gekürzte Antwort der API-Ressource \texttt{users/{userid}/designs/{designID}} als Beispiel für eine XML-Datei
./content/basics/web_services/xml.tex:14:<?xml version="1.0" encoding="UTF-8" standalone="yes"?> //@\ding{202}@//
./content/basics/web_services/xml.tex:33:Eine valide XML-Datei beginnt mit der \emph{XML-Deklaration} \ding{202}, diese enthält Angaben über die verwendete XML-Spezifikation und die Kodierung der Datei. 
./content/basics/web_services/xml.tex:37:Mit Hilfe von \emph{Schemabeschreibungssprachen} (siehe \cref{sec:xmlschema}) kann der Inhalt und die Struktur eines Dokumentes festgelegt und gegen diese validiert werden. Der Begriff \emph{XML Schema} ist mehrdeutig und wird oft auch für eine konkrete Beschreibungssprache, die \enquote{XML Schema Definition}, kurz \gls{XSD}, verwendet.
./content/basics/web_services/json.tex:1:\subsection{JSON}
./content/basics/web_services/json.tex:4:\thesisDefinition{JSON}{
./content/basics/web_services/json.tex:5:\emph{Javascript Object Notation}, kurz \emph{JSON}, ist ein leichtgewichtiges, textbasiertes und sprachunbhängiges Datenaustauschformat. Es ist von JavaScript abgeleitet und definiert eine kleine Menge von Formatierungsregeln für die transportable Darstellung (Serialisierung) von strukturierten Daten (nach \cite{JSONRFC}).
./content/basics/web_services/json.tex:8:Im Gegensatz zu XML ist JSON weit weniger mächtig, es gibt z.B. keine Unterstützung für Namensräume und es wird nur eine geringe Menge an Datentypen unterstützt (siehe \cref{tab:jsonDatatypes}). 
./content/basics/web_services/json.tex:10:Mit \emph{JSON Schema} \cite{json-schema-draft} ist es möglich eine Dokumentstruktur vorzugeben und gegen diese zu validieren. 
./content/basics/web_services/json.tex:24:        \caption{JSON Datentypen}
./content/basics/web_services/json.tex:29:Objekte werden in JSON von geschweiften- \ding{202}, Arrays hingegen von eckigen Klammern begrenzt \ding{203}. 
./content/basics/web_services/json.tex:36:    caption=Die gekürzte Antwort der API-Ressource \texttt{users/{userid}/designs/{designID}} als Beispiel für eine JSON-Datei
./content/basics/web_services/http.tex:1:\section{HTTP}
./content/basics/web_services/http.tex:4:\thesisDefinition{HTTP}{
./content/basics/web_services/http.tex:5:Das \emph{Hypertext Transfer Protocol (HTTP)} ist allgemeines und \emph{zustandsloses} Protokoll, zur Übertragung von Daten über ein Netzwerk, was durch Erweiterung seiner Anfragemethoden, Statuscodes und Header für viele unterschiedliche Anwendungen verwendet werden kann (\cite[][Abstract]{rfc2616}).
./content/basics/web_services/http.tex:8:HTTP arbeitet auf der Anwendungsschicht (\enquote{Application Layer} des OSI-Modells) und ist somit unabhängig von dem zum Datentransport eingesetzten Protokoll. 
./content/basics/web_services/http.tex:9:Über eindeutige \glspl{URI} werden HTTP-Ressourcen angesprochen. Dabei sendet ein \emph{Client} eine Anfrage (\emph{request}) und erhält daraufhin vom Server eine Antwort (\emph{response}). Anfrage und Antwort stellt dabei eine HTTP-Nachricht dar, die aus den zwei Elementen \emph{Header} und \emph{Body} besteht. Letzterer trägt die Nutzdaten und kann, je nach verwendeter HTTP-Methode, auch leer sein.
./content/basics/web_services/http.tex:11:\citetitle{rfc2616} (\cite{rfc2616}) definiert einige HTTP-Methoden, wobei die gebräuchlichsten die folgenden sind:
./content/basics/web_services/http.tex:13:    \item GET
./content/basics/web_services/http.tex:14:    \item PUT
./content/basics/web_services/http.tex:15:    \item POST
./content/basics/web_services/http.tex:16:    \item DELETE
./content/basics/web_services/http.tex:19:%Sie gehören zur Gruppe der sogenannten \emph{CRUD}-Methoden (Create, Receive, Update, Delete) .
./content/basics/web_services/http.tex:20:%\emph{Header} und \emph{Body} bilden die grundlegenden Elemente einer HTTP-Nachricht. 
./content/basics/web_services/http.tex:21:Eine Nachricht kann je nach verwendeter HTTP-Methode auch nur aus einem Header bestehen.
./content/basics/web_services/http.tex:26:Ein Header einer HTTP-Nachricht besteht aus einer \emph{Request Line} (erste Zeile des Headers) und einer Menge von Schlüssel-Wert Paaren. \Cref{lst:headGETrequest} zeigt einen Beispiel Header für die GET Anfrage auf die Spreadshirt-API Ressource:
./content/basics/web_services/http.tex:30:    label=lst:headGETrequest,
./content/basics/web_services/http.tex:31:    caption=HTTP-Header von GET Request auf Spreadshirt-API Ressource \texttt{http://api.spreadshirt.net/api/v1/locales}
./content/basics/web_services/http.tex:33:GET //@\ding{202}@// /api/v1/locales //@\ding{203}@// HTTP/1.1 //@\ding{204}@//
./content/basics/web_services/http.tex:40:    \item[\ding{202}] Angabe der HTTP-Methode
./content/basics/web_services/http.tex:42:    \item[\ding{204}] verwendete HTTP-Version
./content/basics/web_services/http.tex:51:    label=lst:headGETresponse,
./content/basics/web_services/http.tex:52:    caption=HTTP-Header von GET Response aus Spreadshirt-API Ressource \texttt{http://api.spreadshirt.net/api/v1/locales}
./content/basics/web_services/http.tex:54:HTTP/1.1 200 OK //@\ding{202}@//
./content/basics/web_services/http.tex:55:Expires: Tue, 20 Aug 2013 19:05:25 GMT
./content/basics/web_services/http.tex:57:Content-Type: application/xml;charset=UTF-8 //@\ding{203}@//
./content/basics/web_services/http.tex:58:X-Cache-Lookup: MISS from fish07:80
./content/basics/web_services/http.tex:60:True-Client-IP: 88.79.226.66
./content/basics/web_services/http.tex:61:Date: Tue, 20 Aug 2013 07:20:25 GMT
./content/basics/web_services/http.tex:67:    \item[\ding{202}] \emph{Response Line}, Angabe der HTTP-Version am Anfang und danach der HTTP-Statuscode mit Kurzbeschreibung
./content/basics/web_services/http.tex:71:Welche Einträge der Header einer HTTP-Nachricht letztendlich enhtält, ist abhängig von der Implementierung des Clients oder Servers und es können auch jederzeit eigene Einträge, die nicht in der HTTP-Spezifikation enthalten sind, hinzugefügt werden.
./content/basics/web_services/http.tex:76:Der Body enthält die eigentlichen Nutzdaten. Deren Format wird mit dem \emph{Content-Type} Eintrag des Headers angegeben. \Cref{lst:bodyGETresponse} zeigt den Body der \emph{response} von \cref{lst:headGETresponse} in \gls{XML} Format (siehe \cref{sec:xml}).
./content/basics/web_services/http.tex:79:    language=XML,
./content/basics/web_services/http.tex:80:    label=lst:bodyGETresponse,
./content/basics/web_services/http.tex:81:    caption=HTTP-Body der Response aus der GET-Methode auf der Spreadshirt-API-Ressource \texttt{http://api.spreadshirt.net/api/v1/locales}
./content/basics/web_services/http.tex:83:<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
./content/basics/web_services/http.tex:85:    <locale xlink:href="http://api.spreadshirt.net/api/v1/locales/de_DE" id="de_DE"/>
./content/basics/web_services/http.tex:87:    <locale xlink:href="http://api.spreadshirt.net/api/v1/locales/nl_BE" id="nl_BE"/>
./content/basics/web_services/rest.tex:1:\section{RESTful Web Service}
./content/basics/web_services/rest.tex:4:\emph{Representational State Transfer} (deutsch: \enquote{Gegenständlicher Zustandstransfer}) ist ein Softwarearchitekturstil für Webanwendungen, welcher von Roy Fielding\footnote{Roy Thomas Fielding, geboren 1965, ist einer der Hauptautoren der HTTP-Spezifikation} in seiner Dissertation aus dem Jahre 2000  beschrieben wurde \cite[Kapitel 5][95 ff.]{fieldingDissertation}. 
./content/basics/web_services/rest.tex:6:Als \gls{RESTful} bezeichnet man dabei eine Webanwendung die den Prinzipien von \gls{REST} entspricht. 
./content/basics/web_services/rest.tex:9:\subsection{Elemente von REST}
./content/basics/web_services/rest.tex:11:Im folgenden werden die Grundbausteine einer REST-Anwendung erläutert. \Cref{sec:RESTcomponents} beschreibt die Komponenten, die an einer Aktion auf einer \emph{Ressource} beteiligt sind. Dieser Abschnitt basiert auf Kapitel 5.2 von \cite[][S. 86 ff.]{fieldingDissertation}.
./content/basics/web_services/rest.tex:15:Eine Ressource stellt die wichtigste Abstraktion von Information im REST-Modell dar. Fielding definiert eine \emph{ressource} wie folgt:
./content/basics/web_services/rest.tex:22:Außerdem identifiziert ein Ressourcenbezeichner, meist eine \emph{URI} (siehe \cref{sec:unambigiousidentification}), immer dieselbe Ressource, nicht aber deren Wert oder Zustand.
./content/basics/web_services/rest.tex:24:Ein Beispiel für eine Ressource in der Spreadshirt API \texttt{/users/\{userid\}}, wobei \texttt{\{userid\}} die Identifikationsnummer eines konkreten Nutzers bezeichnet. Diese Ressource enthält dabei eine Menge von Elementen, ein Beispiel für eine Ressource die nur ein einziges Element enthält ist \texttt{/serverTime}. 
./content/basics/web_services/rest.tex:29:Aktionen mit Komponenten einer REST-API werden durch den Austausch von solchen Repräsentationen durchgeführt.
./content/basics/web_services/rest.tex:31:Im Allgemeinen wird unter einer Repräsentation nur eine Folge von Bytes verstanden, inklusive \emph{Metainformationen} welche den Inhalt der Bytefolge klassifiziert, sowie \emph{Kontrolldaten} die die gewünschte Aktion oder die Bedeutung der Anfrage beschreiben. Letztere sind meist HTTP-Header-Felder (siehe \cref{sec:http-header}), bspw. um das Cachingverhalten zu ändern.
./content/basics/web_services/rest.tex:35:        language=XML,
./content/basics/web_services/rest.tex:36:        caption=Beispiel zu Metainformationen für REST-Repräsentation aus WADL-Datei der Spreadshirt-API,
./content/basics/web_services/rest.tex:37:        label=lst:metainformationREST
./content/basics/web_services/rest.tex:51:Ein Beispiel für eine solche Angabe von Metainformationen ist in \Cref{lst:metainformationREST} zu finden, \ding{202} zeigt dies in Form einer \emph{Typangabe} und \ding{203} eines \emph{mediaType}-Attributes.
./content/basics/web_services/rest.tex:55:Konnektoren stellen eine Schnittstelle für die Kommunikation mit Komponenten der REST-Webanwendung dar. Aktionen auf Ressourcen und der Austausch von Repräsentationen finden über diese Schnittstellen statt. Der Konnektor bildet die Parameter der Schnittstelle auf das gewünschte Protokoll ab.
./content/basics/web_services/rest.tex:72:%\Cref{tab:RESTconnectors} listet Beispiele für Konnektoren auf.
./content/basics/web_services/rest.tex:81:        server      & libwww, Apache HTTP-Server API\\
./content/basics/web_services/rest.tex:84:        tunnel      & SOCKS\\
./content/basics/web_services/rest.tex:87:        \label{tab:RESTconnectors}
./content/basics/web_services/rest.tex:92:\label{sec:RESTcomponents}
./content/basics/web_services/rest.tex:100:        Ein clientseitiger \emph{Konnektor}, der die Anfrage an die API startet und einziger Empfänger der Antwort ist. In den meisten Fällen ist dies einfach ein \emph{Webbrowser}.
./content/basics/web_services/rest.tex:103:\subsection{REST-Prinzipien}
./content/basics/web_services/rest.tex:105:Die fünf Grundlegenden REST-Prinzipien, nach \cite[11 ff.]{Tilkov09}:
./content/basics/web_services/rest.tex:117:Um eine \emph{eindeutige Identifikation} zu erreichen, wird jeder Ressource eine \gls{URI} vergeben. Dadurch ist es möglich zu jeder verfügbaren Ressource einen Link zu setzen. 
./content/basics/web_services/rest.tex:118:Nachfolgend eine Beispiel-URI, um den Artikel 42 aus dem Warenkorb 84 anzusprechen:
./content/basics/web_services/rest.tex:120:    \underbrace{\texttt{http://api.spreadshirt.net/api/v1/}}_{Basis-URL}\underbrace{\overbrace{\texttt{baskets/84}}^{Warenkorb}\overbrace{\texttt{/item/42}}^{Artikel}}_{Ressource}
./content/basics/web_services/rest.tex:121:    \label{RESTexampleURL}
./content/basics/web_services/rest.tex:127:Innerhalb einer Ressource kann auf weitere verlinkt werden (\emph{Hypermedia}). Als Nebeneffekt der eindeutigen Identifikation durch \glspl{URI} sind diese auch außerhalb des Kontextes der aktuellen Anwendung gültig. 
./content/basics/web_services/rest.tex:136:\gls{REST} ist nicht auf \textsc{Http} beschränkt, praktisch alle REST-APIs nutzen aber dieses Protokoll. Die gebräuchlichsten HTTP-Methoden sind folgende \footnote{Kapitel 9 des HTTP 1.1 RFC2616 beschreibt diese inklusive \emph{TRACE} und \emph{CONNECT} umfassend \cite{rfc2616}}:
./content/basics/web_services/rest.tex:146:Alle bis auf \textsc{Post} und \textsc{Options} sind \emph{idempotent} (\cite{rfc2616} Kapitel 9), d.h. eine hintereinander Ausführung der Methode führt zu demselben Ergebnis wie ein einzelner Aufruf. Dies bedeutet das sich ein \emph{RESTful Web Service} serverseitig ebenso verhalten muss.
./content/basics/web_services/rest.tex:152:Die Client-Anwendung kann dadurch mittels \emph{Query-Parameter} oder als Information im \emph{HTTP-Header} (siehe \cref{sec:http-header}) das gewünschte Format angeben und erhält die entsprechend formatierte Antwort.
./content/basics/web_services/rest.tex:153:Anhand des \emph{Content-Type} Feldes aus dem HTTP-Header kann der Client das Format der Antwort überprüfen, für \gls{JSON} lautet dies bspw. \texttt{application/json}.
./content/basics/web_services/wadl.tex:1:\section{WADL}
./content/basics/web_services/wadl.tex:4:Die \emph{Web Application Description Language} (kurz \gls{WADL}) ist eine maschinenlesbare Beschreibung einer HTTP-basierten Webanwendung, einschließlich einer Menge von \emph{XML Schematas} \cite{hadleyWADL}.
./content/basics/web_services/wadl.tex:5:Die aktuelle Revision ist vom \citedate{WADLcurrent} \cite{WADLcurrent}, im weiteren beziehe ich mich aber auf die in der Spreadshirt-API verwendeten Version, datiert am 9. November 2006. Die Unterschiede zwischen beiden Revisionen können unter \cite{WADLchanges} nachvollzogen werden.
./content/basics/web_services/wadl.tex:7:Die Beschreibung eines Webservices durch WADL besteht nach \cite{hadleyWADL} im groben aus den folgenden vier Bestandteilen:
./content/basics/web_services/wadl.tex:11:     \item[Methods that can be applied to each resource] Die von der jeweiligen Ressource unterstützten [HTTP]-Methoden, deren Ein- und Ausgabe, sowie die unterstützten Formate.
./content/basics/web_services/wadl.tex:12:     \item[Resource representation formats] Die unterstützten \gls{MIME}-Typen und verwendeten Datenschemas (\cref{sec:xsd}).
./content/basics/web_services/wadl.tex:16:\begin{lstlisting}[language=XML, caption={Beispielaufbau einer WADL-Datei anhand der Spreadshirt-API Beschreibung}, label=lst:wadlstructure, name=wadlstructure]
./content/basics/web_services/wadl.tex:17:<?xml version="1.0" encoding="UTF-8" standalone="yes"?> //@\ding{202}@//
./content/basics/web_services/wadl.tex:21:            <doc>Catalog XML Schema.</doc>
./content/basics/web_services/wadl.tex:28:            <method name="GET"> //@\ding{207}@//
./content/basics/web_services/wadl.tex:32:                        xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
./content/basics/web_services/wadl.tex:58:Die Datei beginnt mit der Angabe der XML-Deklaration \ding{202}.
./content/basics/web_services/wadl.tex:59:Die Attribute des Wurzelknotens \texttt{<application>} enthalten \emph{namespace} Definitionen, u. a. auch den der verwendeten WADL-Spezifikation \ding{203}.
./content/basics/web_services/wadl.tex:60:Innerhalb des \texttt{<grammars>} Elements werden die benutzten \emph{XML Schemas} angegeben \ding{204}. 
./content/basics/web_services/wadl.tex:62:Innerhalb des \texttt{<resources>} Elements findet sich die Beschreibung der einzelnen Ressourcen. Diese sind gekennzeichnet, durch eine zur Basisadresse relativen \gls{URI} \ding{206}. In \texttt{\{\ldots\}} eingeschlossene Teile einer \gls{URI}, werden durch den Wert des gleichnamigen \emph{request} Parameters ersetzt um die URI zu bilden (generative URIs).
./content/basics/web_services/wadl.tex:63:Im Folgenden werden die von der Ressource unterstützten HTTP-Methoden beschrieben \ding{207}, deren Anfrageparameter \texttt{<request>} \ding{208}, sowie die möglichen Ausgaben der jeweiligen Methode \texttt{<response>} \ding{209}.
./content/basics/web_services/wadl.tex:65:Die Dokumentations-Tags \texttt{<doc>} sind für alle XML-Elemente optional.
./content/basics/web_services/wadl.tex:68:\Cref{fig:wadlstructure} zeigt die Struktur einer WADL-Datei.
./content/basics/web_services/wadl.tex:77:    \caption{Struktur einer WADL-Datei, nach Kapitel 2 \cite{hadleyWADL}}
./content/basics/web_services.tex:6:In diesem Kapitel werden die Grundlagen zu HTTP, Dokumentbeschreibungssprachen, Webanwendungsbeschreibungsformaten und \gls{REST} erläutert, welche für das Verständnis der Arbeit wichtig sind. 
./content/basics/web_services.tex:7:Neben \gls{XML} und  \gls{JSON} wird auch die Schemabeschreibungssprache \gls{XSD} behandelt.
./content/basics/web_services.tex:8:Das Ende bildet die Einführung in \gls{REST} und \gls{WADL}.
./content/basics/generation_and_modeling/code_generation.tex:13:Folglich ist der Generator die Schnittstelle zwischen dem \emph{Modell-} und \emph{Implementationsraum}. Der Modellraum beinhaltet das \emph{domänenspezifische Modell}. Dieses Modell wird durch die höhersprachige Spezifikation in einer \emph{Systemspezifikationssprache} beschrieben. In Bezug auf einen RESTful Webservice ist bspw. \gls{WADL} inklusive seiner verwendeten Schemata\footnote{siehe \cref{sec:document_description_formats}} die Spezifikationssprache und eine WADL-Datei mit den konkreten Spezifikationen demzufolge das domänenspezifische Modell.
./content/basics/generation_and_modeling/code_generation.tex:44:        Aufgrund des verringerten Implementierungsaufwandes kann der Entwickler mehr Zeit für das Design seiner Architektur, API etc. verwenden. Designfehlentscheidungen können durch Änderungen am Modell oder auch Templates\footnote{Falls der Generator seinen Code über einen Templateansatz erzeugt.} korrigiert werden und bedürfen somit keiner manuellen Korrektur aller generierten Klassen.
./content/basics/generation_and_modeling/conceptual_model.tex:10:Zur Darstellung werden häufig UML- oder ER-Diagramme verwendet, andere Formen sind ebenfalls möglich.
./content/basics/generation_and_modeling/conceptual_model.tex:14:%Ein solches Modell, beispielsweise in Form einer \gls{WADL}-Datei zur Beschreibung einer Web-API, dient als Eingabe für einen Generator. Außerdem ist es der Ausgangspunkt in der modell-getriebenen Softwareentwicklung (\gls{MDSD}) oder -architektur (\gls{MDA}).
./content/basics/generation_and_modeling/oo-languages.tex:4:Ziel des Generators ist die Erzeugung von Code in einer Objektorientierten\footnote{nachfolgend nur noch OO} Sprache. Aus diesem Grund werden die elementaren Konzepte solcher Sprachen in diesem Abschnitt näher erläutert, sowie die Besonderheiten der Generatorzielsprache (PHP) beschrieben.
./content/basics/generation_and_modeling/oo-languages.tex:6:Im Gegensatz zu \emph{Prozeduralen Sprachen} (z.B. C), in denen ein Programm eine Liste von Funktionen ist, wird dieses im OO-Programmierparadigma aus der Interaktion von \emph{Objekten} gebildet. 
./content/basics/generation_and_modeling/oo-languages.tex:8:OO-Sprachen stellen eine Teilmenge der Imperativen Sprachen dar. Programme aus einer Imperativen Sprache bestehen dabei aus einer Folge von \emph{Anweisungen} (\enquote{Statements}). Anweisungen sind Befehle formuliert in der Syntax der Programmiersprache, bspw. Zuweisungen, Unterprogrammaufrufe oder Schleifen. \emph{Ausdrücke} (\enquote{Expressions}) unterscheiden sich zu Anweisungen, indem sie nebenwirkungsfrei sind und nach der Auswertung einen Wert zurückliefern. Viele Programmiersprachen vermischen beide Konstrukte, ein Beispiel dafür ist das Inkrement-Operator (\texttt{++}), er inkrementiert den Wert einer Variable und liefert ihn zurück, ist also nicht nebenwirkungsfrei.
./content/basics/generation_and_modeling/oo-languages.tex:10:\Cref{lst:expression} zeigt den Aufbau eines Ausdrucks dargestellt durch eine EBNF.
./content/basics/generation_and_modeling/oo-languages.tex:13:  style=EBNF, 
./content/basics/generation_and_modeling/oo-languages.tex:14:  language=EBNF,
./content/basics/generation_and_modeling/oo-languages.tex:15:  caption=Aufbau eines Ausdrucks einer Imperativen Programmiersprache als EBNF,
./content/basics/generation_and_modeling/oo-languages.tex:31:Die Beschreibung der Elemente einer OO-Sprache basiert auf \cite{oopSkript2012}.
./content/basics/generation_and_modeling/oo-languages.tex:39:        Die meisten OO-Sprachen bieten Möglichkeiten der Vererbung, d.h. das Klassen gewisse Eigenschaften und Methoden von einer Klasse \enquote{erben} können. Weiterhin können Klassen auch abstrakt sein, also die in ihnen enthaltenen Klassen und Methoden sind nur Bezeichner aber besitzen keine Definition. Diese müssen dann von den klassen definiert werden die diese Abstrakten Klassen \emph{implementieren}.
./content/basics/generation_and_modeling/oo-languages.tex:47:        Namensräume erlauben die Verwendung von gleichen Bezeichnern in unterschiedlichen Namensräumen. Wie im Punkt Objekte erwähnt, bilden diese bspw. einen eigenen Namensraum. Der Zugriff auf ein Element eines Objektes erfolgt über seinen Namensraum, will man auf das Element \texttt{bar} des Objektes \texttt{foo} zugreifen, geschieht dies z.B. in PHP folgendermaßen: \texttt{foo->bar}.
./content/basics/generation_and_modeling/oo-languages.tex:49:        % PHP als Beispiel
./content/basics/generation_and_modeling/oo-languages.tex:55:\citeauthor{voelterDSLEngineering} definiert den Begriff \enquote{Typsystem} auf \cite[][S. 253]{voelterDSLEngineering} so (eigene Übersetzung):
./content/basics/generation_and_modeling/oo-languages.tex:65:\subsection{PHP}
./content/basics/generation_and_modeling/oo-languages.tex:68:PHP ist eine \gls{GPL} die aber vorwiegend auf die Entwicklung von serverseitigen Webapplikationen ausgerichtet ist. PHP Skripte können in HTML-Dateien eingebettet werden, welche der Server bei einer Client-Anfrage verarbeitet, die PHP Elemente durch deren Ausgabe ersetzt und dem Client zurücksendet. Die Sprache gehört somit zu den \emph{Server-Side Scripting Languages}. Die Verwendung ist aber nicht auf diesen Bereich beschränkt, denn PHP Anweisungen müssen nicht in HTML eingebettet sein sondern können auch unabhängig davon, als eigene Datei, ausgeführt werden.
./content/basics/generation_and_modeling/oo-languages.tex:69:Im Gegensatz zu \emph{Java} ist PHP nicht statisch typisiert und muss zur Ausführung auch nicht kompiliert werden. PHP ist \emph{dynamisch typisiert} und wird von einem Interpreter --- dem namensgebenden \emph{Hypertext Preprocessor} --- ausgeführt.
./content/basics/generation_and_modeling/oo-languages.tex:72:\begin{lstlisting}[language=php, caption=Durch den Generator erzeugte BatchDTO Datenklasse der Spreadshirt-API als Beispiel für eine PHP-Datei]
./content/basics/generation_and_modeling/oo-languages.tex:75:   require_once('OperationDTO.php'); //@\ding{203}@//
./content/basics/generation_and_modeling/oo-languages.tex:77:   class BatchDTO
./content/basics/generation_and_modeling/oo-languages.tex:79:      private $operations = array(); // operationDTO 
./content/basics/generation_and_modeling/oo-languages.tex:81:      function __construct(operationDTO //@\ding{204}@// $operations) 
./content/basics/generation_and_modeling/oo-languages.tex:91:      public function setOperations(operationDTO $operations)
./content/basics/generation_and_modeling/oo-languages.tex:96:      public function toJSON()
./content/basics/generation_and_modeling/oo-languages.tex:98:         $json = json_decode(/* BatchDTO */ $this);
./content/basics/generation_and_modeling/oo-languages.tex:104:      public static //@\ding{205}@// function fromXML(SimpleXMLElement $xml)
./content/basics/generation_and_modeling/oo-languages.tex:106:         $operations = OperationDTO::fromXML(/* SimpleXMLElement */ $xml->operations);
./content/basics/generation_and_modeling/oo-languages.tex:107:         $BatchDTO =  new BatchDTO(/* operationDTO */ $operations);
./content/basics/generation_and_modeling/oo-languages.tex:108:         return $BatchDTO;
./content/basics/generation_and_modeling/oo-languages.tex:118:    \item[\ding{202}] Start- und Endtags eines PHPFiles, wobei letzteres optional ist. Deren Funktion ist die Abgrenzung vom umliegenden Markup, bspw. wenn der PHP-Code in eine HTML Datei eingebettet ist.
./content/basics/generation_and_modeling/oo-languages.tex:119:    \item[\ding{203}] PHP unterstützt das importieren von Quellcodefiles anhand verschiedener Befehle, in diesem Fall \texttt{require\_once}.
./content/basics/generation_and_modeling/dsl.tex:1:\subsection{Domain Specific Language (DSL)}
./content/basics/generation_and_modeling/datamodel.tex:21:Wie man in \Cref{fig:wadlstructure} erkennen kann, entspricht die Struktur einer WADL-Datei einem Baum. Aus diesem Grund eignet sich eine Baumstruktur für das Datenmodell des Generators besonders gut. Um die Zielsprache (siehe \cref{sec:target_language}) im internen Datenmodell abbilden zu können, wird ein \gls{AST} als Datenstruktur gewählt.
./content/basics/generation_and_modeling/datamodel.tex:23:\subsection{Abstract Syntax Tree (AST)}
./content/basics/generation_and_modeling/datamodel.tex:35:Er ist das Endprodukt eines Parsingschrittes des Quelltextes, im Gegensatz zum \emph{konkreten Syntaxbaum} (auch \emph{Parse Tree}) enthält der \emph{AST} keine Formatierungsspezifische Syntax (bspw. Klammern). 
./content/basics/generation_and_modeling/datamodel.tex:66:    \caption{Beispiel AST für den rekursiven euklidischen Algorithmus}
./content/basics/generation_and_modeling/datamodel.tex:70:%Ein \emph{AST} bildet auch die Grundstruktur des Datenmodells für den Generator. 
./content/generation_for_spreadshirt-api/data_models/schema_model.tex:7:    \caption{UML Klassendiagramm des Schemadatenmodells}
./content/generation_for_spreadshirt-api/data_models/schema_model.tex:13:XSD-Dateien (siehe \cref{sec:xsd}) erlauben das importieren anderer Schemadefinitionen, die Klasse \textbf{Import} ermöglicht dies im Schemamodell. Sie besitzt ein Objekt des zu importierenden Schemas sowie eine URI auf die zugehörige XSD-Datei.
./content/generation_for_spreadshirt-api/data_models/schema_model.tex:35:            language=XML,
./content/generation_for_spreadshirt-api/data_models/schema_model.tex:36:            caption=Point Datentyp aus der Spreadshirt-API Schemabeschreibung,
./content/generation_for_spreadshirt-api/data_models/language_model.tex:23:\textbf{Dependency} enthält das Schlüsselwort oder Methodenaufruf zum Import einer Quellcodedatei. In PHP werden solche Dateien bpsw. so importiert: \texttt{require\_once("foo.php");}.
./content/generation_for_spreadshirt-api/data_models/language_model.tex:45:Operatoren der Zielsprache müssen das Interface \textbf{Operator} implementieren, ein Operator ist durch seine Arität (Stelligkeit), Notation und sein Symbol gekennzeichnet. Zum Beispiel der Dereferenzierungsoperator in PHP ist zweistellig, Infix notiert und wird gekennzeichnet durch das Symbol \texttt{->}.
./content/generation_for_spreadshirt-api/data_models/language_model.tex:52:    \caption{UML Klassendiagramm des Zielsprachenmodells}
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:1:\subsection{REST-Modell}
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:4:Zuerst muss die abstrakte Beschreibung der Spreadshirt-API von der XML-Form, bestehend aus einem \emph{WADL} (\cref{sec:wadl}) und einem oder mehreren Schemabeschreibungen (siehe \cref{sec:document_description_formats}), in ein für den Generator verarbeitbares Format überführt werden.
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:6:Die durch die WADL-Datei beschriebene Baumstruktur muss in ein Datenmodell bestehend aus Klassen und Objekten transformiert werden.
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:7:Um effektiv mit der XML Darstellung arbeiten zu können wird diese zuerst mit einem Parser (siehe \cref{sec:xml_parser}) in ein \emph{Document Object Model} (kurz DOM) überführt welches im Arbeitsspeicher gehalten wird und damit einen schnellen Zugriff für nachfolgende Operationen darauf erlaubt. In einem nächsten Schritt wird das DOM, welches noch viele XML spezifische Informationen enthält, auf die wesentlichen API beschreibenden Merkmale reduziert. Im Gegensatz zu der in \cref{fig:wadlstructure} veranschaulichten Webanwendungsbeschreibung werden Referenzen durch deren Definition im Modell ersetzt. Die Klassenamen des Datenmodells orientieren sich an den WADL Elementnamen.
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:12:    \caption{UML Klassendiagramm des REST-Modells}
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:16:Wurzelelement des Modells (siehe \cref{fig:restmodel}) ist die Klasse \textbf{Application}, sie enthält \emph{Ressource}-Objekte und den Basisbezeichner der API bspw. \texttt{\small http://api.spreadshirt.net/api/v1/}. 
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:24:\textbf{Parameter} enthält Angaben zum \emph{Style}, Typ, Vorgabewert und ob dessen Angabe \enquote{required}, also notwendig ist. Die Angabe des Typs ist eine Referenz auf einen Typ aus einer XML-Schemabeschreibung. Der \emph{Style} gibt an wie der Parameter übermittelt wird, als Teil der Query \texttt{?mediaType=xml}, \emph{Key-Value Pair} des HTTP-Header oder als \emph{Template-Parameter} des Ressourcenbezeichners. 
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:26:Die Klasse \textbf{Response} enthält eine Liste mit \emph{Representation}-Objekten und Parameter-Objekten. Die Objekte vom Typ Representation enthalten die Beschreibung der Daten die bei einer erfolgreichen Anfrage an die Ressource zurückgesendet werden, sowie die der Fehlermeldung welche der Client anderenfalls erhält. Zwischen einer Fehlermeldung und einer erfolgreichen Anfrage kann anhand des Werts des HTTP-Statuscodes unterschieden werden. Erfolgreiche Anfragen liefern in der Antwort smeist einen Statuscode 200 \textbf{OK} oder 201 \textbf{Created} zurück, abhängig von der Anfragemethode. Die Response Parameter geben Einträge im HTTP-Header an, welche für den Client nützliche Informationen enthalten. Legt der Client z.B. via POST auf der Ressource \texttt{sessions} eine neue API-Session an, so enthält das Feld \texttt{Location} des HTTP-Headers der Serverantwort eine URL auf die Ressource der angelegten Session.
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:28:Die \textbf{Representation}-Klasse dient zur Beschreibung der Daten welche entweder zur API gesendet oder von dieser empfangen werden, sie besteht aus einer Angabe des \emph{media-type}, des HTTP-Statuscodes und eine Referenz auf die Definition des Datentyps. Das \emph{Representation}-Objekt des Request einer PUT- oder POST-Methode charakterisiert zum Beispiel den Aufbau der Daten welche der Ressource übermittelt werden, üblicherweise im HTTP-Body. Die Charakterisierung erfolgt dabei in Form einer Referenz auf einen Typ aus einer Schemabeschreibung sowie der Angabe des \emph{media-type}. Beispielsweise enthält das \emph{Representation}-Objekt der PUT-Methode auf Ressource \texttt{users/\{userId\}/designs/\{designId\}} den media-type \texttt{application/xml} und eine Referenz auf den Typ \texttt{sns:design}. 
./content/generation_for_spreadshirt-api/data_models/rest_model.tex:30:Referenzen auf Typdeklaration aus einer Schemabeschreibung werden nachfolgend im Modell durch die konkrete Deklaration des Typs aus der XML-Schemabeschreibung ersetzt, siehe \cref{sec:application_model}. 
./content/generation_for_spreadshirt-api/generation_for_spreadshirt-api.tex:1:\chapter{Codegenerierung für die Spreadshirt-API}
./content/generation_for_spreadshirt-api/api-design.tex:1:\section{API-Design}
./content/generation_for_spreadshirt-api/concrete_model.tex:13:Das Applikationsmodell ist die Gesamtheit des REST- und Schemamodells. Referenzen auf Typenbeschreibungen im REST-Modell werden durch deren Definition im Schemamodell ersetzt. Dieses gemeinsame Modell dient dem Generator als Eingabequelle.
./content/implementation/xml_parser.tex:1:\section{XML-Parser}
./content/implementation/xml_parser.tex:5:Um mit der abstrakten Beschreibung der Spreadshirt-API arbeiten zu können, muss diese zuerst in das interne Datenmodell überführt werden. Diese liegt in XML-basierter Form vor, welche in \cref{sec:web_services} näher beschrieben wurde. Folglich wird ein XML-Parser für die Verarbeitung der Beschreibungsformate benötigt.  
./content/implementation/xml_parser.tex:7:Die \emph{Java API for XML Processing} kurz \emph{JAXP} abstrahiert die Parserschnittstelle von der eigentlichen Implementierung. JAXP ist dabei keine einzelne API sondern es beschreibt Schnittstellen für folgende vier XML-Parser Modelle:
./content/implementation/xml_parser.tex:10:    \item[DOM] \emph{Document Object Model}-Parser überführen das XML-Dokument in ein baumartiges Objektmodell, welches vollständig im Arbeitsspeicher liegt.
./content/implementation/xml_parser.tex:11:    \item[SAX] \emph{Simple API for XML} basierte, sogenannte Push-Parser verarbeiten das XML-Dokument seriell und eventbasiert. Ein Event ist hierbei bspw. ein öffnendes oder schließendes XML-Element.
./content/implementation/xml_parser.tex:12:    \item[StAX] \emph{Streaming API for XML} basierte, sogenannte Pull-Parser arbeiten ebenso wie bei \emph{SAX} seriell und eventbasiert, können aber im Gegensatz dazu die Erzeugung von Events selber steuern. 
./content/implementation/xml_parser.tex:13:    \item[TrAX] \emph{Transformation API for XML} bietet eine Schnittstelle mit der sich XML-Dokumente durch \emph{Extensible Stylesheet Language Transformations (XSLT)} in Java transformieren lassen.
./content/implementation/xml_parser.tex:16:\Cref{tab:xmlParsingModels} enthält eine Übersicht zu den Parsing-Konzepten, ausgenommen \emph{TrAX} da diese API vorwiegend für die Modifikation von XML-Dateien gedacht ist.
./content/implementation/xml_parser.tex:18:Bei dem zu entwickelnden Codegenerator sind der Speicherverbrauch und die verwendete CPU-Zeit kein Teil der \emph{nichtfunktionalen Anforderungen}, somit fiel die Entscheidung auf einen DOM-Parser. Dieser lässt sich durch das komplett im Speicher gehaltene Objektmodell mit geringem Aufwand verwenden. Durch JAXP ist die Implementierung transparent und es wird die im \emph{JDK} enthaltene Standart DOM-Parser Implementierung verwendet.
./content/implementation/xml_parser.tex:24:        & \textbf{DOM}   & \textbf{SAX}   & \textbf{StAX} \\
./content/implementation/xml_parser.tex:26:        \textbf{API-Typ}                    & In-Memory Tree    & push-streaming    & pull-streaming\\
./content/implementation/xml_parser.tex:27:        \textbf{Speicherverbrauch}          & hoch              & gering            & \textless{} DOM\\
./content/implementation/xml_parser.tex:31:        \textbf{XML schreiben}              & ja                & nein              & ja \\
./content/implementation/xml_parser.tex:33:        \caption{Übersicht über die verschiedenen XML-Parsing Konzepte in JAXP}
./document.tex:5:%\KOMAoptions{twoside = false} % creates the "dirty hack"-error
./document.tex:7:  %\KOMAoptions{twoside}
./document.tex:9:  \KOMAoptions{twoside = false} % creates the "dirty hack"-error
./document.tex:24:% PDF meta-data
./document.tex:73:% manuelles einfuegen eines Lesezeichens im PDF-Index
./document.tex:96:    % http://www2.informatik.hu-berlin.de/~piefel/LaTeX-PS/Archive-2004/V07-footnote.pdf
./tikz_pgf/generatorstructure.tex:6:    \node(abstract)[greyBlock, double copy shadow]{abstrakte\\API Beschreibung};
./tikz_pgf/generatorstructure.tex:8:    \node(APImodel)[greyBlock, right=of parser]{REST-API\\Modell};
./tikz_pgf/generatorstructure.tex:9:    \node(generator)[greyBlock, right=of APImodel]{Codegenerator\\\textbf{Java}};
./tikz_pgf/generatorstructure.tex:13:	\node(bib)[greyBlock, right=of printer]{Client-Bibliothek\\\textbf{PHP}};
./tikz_pgf/generatorstructure.tex:16:	\path[arrow, ->] (parser) -- (APImodel);
./tikz_pgf/generatorstructure.tex:17:    \path[arrow, ->] (APImodel) -- (generator);
./tikz_pgf/wadlstructure.tex:223:                    nur PUT \& POST\\
./tikz_pgf/simplifiedGeneratorModel.tex:8:            \node(wadl)[greyBlock]{WADL};
./tikz_pgf/simplifiedGeneratorModel.tex:9:            \node(xsd)[double copy shadow, greyBlock,below of=wadl]{XSD};
./tikz_pgf/generation_sequence.tex:6:    \node(abstractDescription)[greyBlock]{Abstrakte\\Beschreibung\\der Spreadshirt-API};
./tikz_pgf/generation_sequence.tex:8:    \node(wadlAnalysis)[greyBlock, above right=of abstractDescription]{Analyse\\WADL-Datei};
./tikz_pgf/generation_sequence.tex:9:    \node(restModel)[greyBlock, right=of wadlAnalysis]{REST-\\Modell};
./tikz_pgf/generation_sequence.tex:10:    \node(xsdAnalysis)[greyBlock, below right=of abstractDescription]{Analyse\\XSD-Datei};
./tikz_pgf/xsd_predefined_types.tex:29:                                child {node[greenBox] {NCName}
./tikz_pgf/xsd_predefined_types.tex:30:                                    child {node[greenBox] {ID}}
./tikz_pgf/xsd_predefined_types.tex:31:                                    child {node[greenBox] {IDREF}
./tikz_pgf/xsd_predefined_types.tex:32:                                        child {node[greenBox] {IDREFS}
./tikz_pgf/xsd_predefined_types.tex:36:                                    child {node[greenBox] {ENTITY}
./tikz_pgf/xsd_predefined_types.tex:37:                                        child {node[greenBox] {ENTITIES}
./tikz_pgf/xsd_predefined_types.tex:43:                            child {node[greenBox] {NMTOKEN}
./tikz_pgf/xsd_predefined_types.tex:44:                                child  {node [greenBox] {NMTOKENS}
./tikz_pgf/xsd_predefined_types.tex:82:                child {node[blueBox] {anyURI}}
./tikz_pgf/xsd_predefined_types.tex:83:                child {node[blueBox] {QName}}
./tikz_pgf/xsd_predefined_types.tex:84:                child {node[blueBox] {NOTATION}}
./header/settings.tex:102:		%frame=tb 	%tblrTBLR
./header/settings.tex:106:\lstdefinestyle{EBNF}{
./header/settings.tex:124:\lstdefinelanguage{EBNF}{
./header/settings.tex:214:%\newcommand{footerOrnament}{\includegraphics[width=32pt]{frontpage/HTWK_Logo_schwarz}}
./header/settings.tex:217:%\newcommand{\footerOrnament}{\raisebox{-8pt}{\includegraphics[width=\footerlogowidth]{frontpage/HTWK_Logo_schwarz}}}
./thesis.tex:12:\documentclass[a4paper, headsepline, ngerman, twoside, headings=openright, open=right, headinclude=false, DIV=calc]{scrreprt} % 12pt
./appendix/glossary.tex:6:		Parsing oder auch \emph{Syntaxanalyse} erzeugt aus einer Zeichenkette einen \gls{AST} aufgrund der Regeln einer Grammatik. Der Aufbau der Zeichenkette wird also nach den Regeln der Grammatik analysiert und die einzelnen Elemente in einen \gls{AST} überführt.
./appendix/glossary.tex:10:\newglossaryentry{REST}{
./appendix/glossary.tex:14:		Beispiel-URL für das Item \emph{84} aus dem Warenkorb \emph{42}:\\
./appendix/glossary.tex:19:\newglossaryentry{RESTful}{
./appendix/glossary.tex:22:		Als \emph{RESTful} bezeichnet man einen Webservice der den Prinzipien von REST entspricht
./appendix/glossary.tex:24:	see=REST
./appendix/glossary.tex:27:\newglossaryentry{API}{
./appendix/glossary.tex:28:	name=\textsc{API}, 
./appendix/glossary.tex:34:\newglossaryentry{XML}{
./appendix/glossary.tex:35:	name=\textsc{XML},
./appendix/glossary.tex:37:		\emph{Extensible Markup Language} (deutsch: \enquote{erweiterbare Auszeichnungssprache}) ist ein Mensch- und Maschinenlesbares Format für Codierung und Austausch von Daten, \printhref{http://www.w3.org/TR/REC-xml}{spezifiziert vom W3C}
./appendix/glossary.tex:41:\newglossaryentry{JSON}{
./appendix/glossary.tex:42:	name=\textsc{JSON},
./appendix/glossary.tex:44:		\emph{JavaScript Object Notation} ist ein Mensch- und Maschinenlesbares Format zu Codierung und Austausch von Daten. Bietet im Gegensatz zu XML keine Erweiterbarkeit und Unterstützung für Namesräume, ist aber kompakter und einfacher zu parsen
./appendix/glossary.tex:46:	see=XML
./appendix/glossary.tex:49:\newglossaryentry{XSD}{
./appendix/glossary.tex:50:	name=\textsc{XSD},
./appendix/glossary.tex:52:		\emph{XML Schema Description}, auch nur \emph{XML Schema}, ist eine Schemabeschreibungssprache und enthält Regeln für den Aufbau und zum Validieren einer XML-Datei. Die Beschreibung ist selbst wieder eine gültige XML-Datei
./appendix/glossary.tex:54:	see=XML
./appendix/glossary.tex:57:\newglossaryentry{RelaxNG}{
./appendix/glossary.tex:58:	name=\textsc{RelaxNG},
./appendix/glossary.tex:60:		\emph{Regular Language Description for XML New Generation} ist ebenso wie \emph{XSD} eine Schemabeschreibungssprache, bietet aber zwei Syntaxformen, eine XML basierte und eine kompaktere eigene Syntax
./appendix/glossary.tex:62:	see=XSD
./appendix/glossary.tex:65:\newglossaryentry{WADL}{
./appendix/glossary.tex:66:	name=\textsc{WADL},
./appendix/glossary.tex:68:		\emph{Web Application Description Language} ist eine maschinenlesbare Beschreibung einer HTTP-basierten Webanwendung
./appendix/glossary.tex:70:	see=XML
./appendix/glossary.tex:87:\newglossaryentry{DSL}{
./appendix/glossary.tex:88:	name=\textsc{DSL},
./appendix/glossary.tex:101:\newglossaryentry{MIME}{
./appendix/glossary.tex:102:	name=\textsc{MIME},
./appendix/glossary.tex:108:\newglossaryentry{URI}{
./appendix/glossary.tex:109:	name=\textsc{URI},
./appendix/glossary.tex:113:	plural=URIs
./appendix/glossary.tex:116:\newglossaryentry{URL}{
./appendix/glossary.tex:117:	name=\textsc{URL},
./appendix/glossary.tex:119:		\emph{Unified Resource Locator} sind eine Untermenge der \emph{URIs}. Der Unterschied besteht in der expliziten Angabe des Zugrissmechanismus und des Ortes (\enquote{Location}) durch \emph{URLs}, bspw. \texttt{http} oder \texttt{ftp}
./appendix/glossary.tex:121:	see=URI
./appendix/glossary.tex:124:\newglossaryentry{DTD}{
./appendix/glossary.tex:125:	name=\textsc{DTD},
./appendix/glossary.tex:127:		\emph{Document Type Definition}, manchmal auch \emph{Data Type Definition}, ist eine Menge von Angaben die einen Dokumenttyp beschreiben. Es werden konkret Element- und Attributtypen, Entitäten und deren Struktur beschrieben. Die bekanntesten Schemasprachen für XML-Dokumente sind XSD und RelaxNG
./appendix/glossary.tex:129:	see=XSD
./appendix/glossary.tex:133:\newglossaryentry{MDA}{
./appendix/glossary.tex:134:	name=\textsc{MDA},
./appendix/glossary.tex:136:		\emph{Model Driven Architecture} ist ein modell-getriebener Softwareentwicklungsansatz. Das zu modellierende System wird hierbei durch ein plattformunabhängiges Modell beschrieben mittels einer \gls{DSL} beschrieben. Dieses Modell wird dann durch einen Generator in ein plattformspezifisches Modell, meist in einer \gls{GPL} übersetzt
./appendix/glossary.tex:141:\newglossaryentry{MDSD}{
./appendix/glossary.tex:142:	name=\textsc{MDSD},
./appendix/glossary.tex:148:\newglossaryentry{MDE}{
./appendix/glossary.tex:149:	name=\textsc{MDE},
./appendix/glossary.tex:153:	see=MDSD
./appendix/glossary.tex:156:\newglossaryentry{AST}{
./appendix/glossary.tex:159:		Ein \emph{Abstrakter Syntaxbaum} ist die Baumdarstellung einer abstrakten Syntaktischen Struktur von Quellcode einer Programmiersprache. Jeder Knoten des Baumes kennzeichnet ein Konstrukt des Quellcodes. Der \emph{AST} stellt für gewöhnlich nicht alle Details des Quelltextes dar, bspw. formatierende Element wie etwa Klammern werden häufig weggelassen.
./appendix/glossary.tex:163:\newglossaryentry{GPL}{
./appendix/glossary.tex:166:		Eine \emph{General Purpose Language} bezeichnet eine Programmiersprache welche für den Einsatz in den verschiedensten Anwendungsbereichen verwendet kann, im Gegensatz zur einer \gls{DSL}, welche nur auf einen speziellen Bereich beschränkt ist.
./abstract.tex:13:Codegenerierung, RESTful Web Service, Modellierung, Client-Bibliothek, Spreadshirt-API, Polyglot
./thesis_print.tex:13:\documentclass[a4paper, headsepline, ngerman, twoside, headings=openright, open=right, headinclude=false, DIV=calc, BCOR=10mm]{scrreprt}
./bibtex_entry.tex:20:	school = {HTWK-Leipzig},
./bibtex_entry.tex:22:	%ToDo: PUT IN THE URL
./frontpage/frontpage.tex:6:    \includegraphics[width=4cm]{frontpage/HTWK_Logo_schwarz}\\
./frontpage/frontpage.tex:56:        HTWK Leipzig, F-IMN, Postfach 301166, 04251 Leipzig\\
./frontpage/frontpage.tex:62:        Spreadshirt HQ, Gießerstraße 27, 04229 Leipzig\\
./frontpage/title_backside.tex:18:    Bachelor Thesis, HTWK-Leipzig, \today\\
./license.tex:3:Die vorliegende Bachelorthesis \enquote{\thesisTitle{}} is unter Creative Commons \printhref{http://creativecommons.org/licenses/by-sa/3.0/deed.de}{CC-BY-SA} lizenziert.
./variables/global.tex:8:\newcommand{\thesisAuthorClass}{10INB-T}
./variables/global.tex:10:\newcommand{\thesisUniversity}{HTWK Leipzig}
./variables/global.tex:12:\newcommand{\thesisTitle}{Generierung und Design einer Client-Bibliothek für einen RESTful Web Service am Beispiel der Spreadshirt-API}
