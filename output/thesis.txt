HTWK Leipzig
Fakultät für Informatik, Mathematik & Naturwissenschaften

Bachelorarbeit
Generierung und Design einer Client-Bibliothek für
einen RESTful Web Service am Beispiel der
Spreadshirt-API
Author:

Andreas Linz
10INB-T
admin@klingt.net
Leipzig, 2. Oktober 2013

Gutachter:

Dr. rer. nat. Johannes Waldmann
HTWK Leipzig – Fakultät für Informatik, Mathematik & Naturwissenschaften
waldmann@imn.htwk-leipzig.de
HTWK Leipzig, F-IMN, Postfach 301166, 04251 Leipzig

Jens Hadlich
Spreadshirt HQ, Gießerstraße 27, 04229 Leipzig
jns@spreadshirt.net

Diese Seite wurde mit Absicht leer gelassen.

Andreas Linz
Nibelungenring 52
04279 Leipzig
admin@klingt.net
www.klingt.net
Generierung und Design einer Client-Bibliothek für einen
RESTful Web Service am Beispiel der Spreadshirt-API
Bachelorarbeit, HTWK Leipzig, 2. Oktober 2013
made with XƎTEX and BibTEX.

Selbständigkeitserklärung
Ich erkläre hiermit, dass ich diese Bachelorarbeit selbstständig ohne Hilfe Dritter und ohne Benutzung anderer als der angegebenen Quellen und Hilfsmittel
verfasst habe. Alle den benutzten Quellen wörtlich oder sinngemäß entnommenen Stellen sind als solche einzeln kenntlich gemacht.
Diese Arbeit ist bislang keiner anderen Prüfungsbehörde vorgelegt und auch
nicht veröﬀentlicht worden.
Ich bin mir bewusst, dass eine falsche Erklärung rechtliche Folgen haben wird.

Andreas Linz
Leipzig, 2. Oktober 2013

I

Danksagungen
Ein besonderer Dank gilt Dr. rer. nat. Johannes Waldmann für die Anregungen und Ratschläge sowie das gezeigte Interesse am Thema.
Ebenso möchte ich mich bei Jens Hadlich bedanken, der für Fragen jederzeit
ein oﬀenes Ohr hatte und mir half den »roten Faden« bei der Strukturierung
der Arbeit nicht zu verlieren. Außerdem gilt Spreadshirt ein großer Dank, da
sie mir eine wunderbare Arbeitsumgebung sowie nette und hilfreiche Kollegen
zur Verfügung gestellt haben.
Ohne Elisa Jentsch würde sicherlich der ein oder andere Rechtschreibfehler
den Leseﬂuss trüben, deshalb vielen Dank für das Korrekturlesen.

II

Abstract
German
Die vorliegende Arbeit beschreibt den Entwurf eines Codegenerators mit austauschbarer Zielsprache, der aus der abstrakten Beschreibung der SpreadshirtApi eine Client-Bibliothek generieren soll. Die Implementierung des Codegenerators erfolgt in Java, die Zielsprache der Bibliothekt ist Php.
Es werden die Grundlagen von WebServices, Codegeneratoren und Dokumentbeschreibungssprachen erläutert und darauf aufbauend Datenmodelle erstellt welche die Beschreibung der Spreadshirt-Api für den Generator enthalten.
Außerdem wird das erstellte Sprachenmodell betrachtet, welches die Konstrukte der zu erzeugenden Zielsprache kapselt. Aufbau und Ablauf eines Codegeneratorsystems werden ebenfalls beschrieben.
Die durch den Codegenerator erstellte Client-Bibliothek wird anhand eines
Anwendungsbeispieles evaluiert.

English
The present thesis describes the design of a codegenerator with exchangeable
target-language, that generates a client-library from the abstract description
of the Spreadshirt-Api. The implementation of the codegenerator is made in
Java, the target-language of the client-library is Php.
The basics of web services, codegenerators and document-description-languages
will be explained and based on that datamodels will be created, that contains
the description of Spreadshirt-Api, for the generator. Furthermore the created language-model will be examined, which encapsulates the constructs of the

III

target-language that will be generated. Structure and process of a codegeneratorsystem will be described, as well.
The client-library that was created by the codegenerator will be evaluated
on the basis of a usage example.

Keywords
Codegeneration, Restful Web Service, Modeling, Client-Library, SpreadshirtApi, Polyglot

Lizenz
Die vorliegende Bachelorarbeit Generierung und Design einer ClientBibliothek für einen RESTful Web Service am Beispiel der SpreadshirtAPI ist unter Creative Commons CC-BY-SA 1 lizenziert.

1

http://creativecommons.org/licenses/by-sa/3.0/deed.de

V

Inhaltsverzeichnis
1. Einführung
1.1. Anforderungen an die Client-Bibliothek . . . . . . . . . . . . .
1.2. Typographische Konventionen dieser Bachelorarbeit . . . . . .

2
4
4

2. Web Services
2.1. Adressierung . . . . . . . . . . . . . . . . . . . . . .
2.2. HTTP . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.1. Methoden . . . . . . . . . . . . . . . . . . . .
2.2.2. Header . . . . . . . . . . . . . . . . . . . . . .
2.2.3. Body . . . . . . . . . . . . . . . . . . . . . . .
2.3. Dokumentbeschreibungsformate . . . . . . . . . . . .
2.3.1. XML . . . . . . . . . . . . . . . . . . . . . . .
2.3.2. JSON . . . . . . . . . . . . . . . . . . . . . .
2.4. XML Schemabeschreibungssprachen (XML Schema)
2.4.1. XML Schema Description (XSD) . . . . . . .
2.5. RESTful Web Service . . . . . . . . . . . . . . . . .
2.5.1. Elemente von REST . . . . . . . . . . . . . .
2.5.2. REST-Prinzipien . . . . . . . . . . . . . . . .
2.6. WADL . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

6
6
8
8
9
10
11
11
12
13
14
17
17
21
23

3. Codegenerierung
3.1. Codegeneratoren . . . . . . . . . . . . . .
3.1.1. Aufgaben eines Generators . . . .
3.1.2. Vorteile für den Entwickler . . . .
3.1.3. Generatorformen . . . . . . . . . .
3.1.4. Optimierung durch den Generator
3.2. Datenmodell . . . . . . . . . . . . . . . .
3.2.1. Abstract Syntax Tree (AST) . . .
3.3. Objektorientierte Sprachen . . . . . . . .
3.3.1. Elemente . . . . . . . . . . . . . .
3.3.2. Typsystem . . . . . . . . . . . . .
3.3.3. PHP . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

28
28
29
29
30
31
32
32
33
34
36
36

VI

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

4. Generatorsystem für die Spreadshirt-API
4.1. Konkrete Datenmodelle . . . . . . . . . .
4.1.1. REST-Modell . . . . . . . . . . . .
4.1.2. Schema-Modell . . . . . . . . . . .
4.1.3. Applikationsmodell . . . . . . . . .
4.1.4. Sprachenmodell . . . . . . . . . . .
4.2. Codegenerator . . . . . . . . . . . . . . .
4.2.1. Language Factory . . . . . . . . .
4.2.2. Ausgabemodul . . . . . . . . . . .
4.2.3. Generatorablauf . . . . . . . . . .
4.3. Client-Bibliothek . . . . . . . . . . . . . .
4.3.1. Datenklassen . . . . . . . . . . . .
4.3.2. Ressourcenklassen . . . . . . . . .
4.3.3. De-/Serialisierer . . . . . . . . . .
4.3.4. Statische Klassen . . . . . . . . . .

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

39
39
39
42
44
44
48
48
49
49
49
51
53
55
55

5. Evaluierung
5.1. PHP-Zielsprachenmodell . . . . . . . . . . . . . .
5.1.1. Implementierung einer Zielsprache . . . .
5.1.2. Codestyle/Lesbarkeit . . . . . . . . . . . .
5.2. Typsicherheit . . . . . . . . . . . . . . . . . . . .
5.3. Generierung von Tests für die erzeugte Bibliothek
5.4. Metriken . . . . . . . . . . . . . . . . . . . . . . .
5.5. Leistungsbewertung . . . . . . . . . . . . . . . .
5.6. Nutzbarkeit . . . . . . . . . . . . . . . . . . . . .

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

57
57
57
59
59
60
60
61
63

6. Schlussbetrachtung
6.1. Ausblick . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2. Fazit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

64
64
65

A. Implementierung
A.1. XML-Parser . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

A
A

Glossar

C

Abbildungsverzeichnis

F

Tabellenverzeichnis

G

Listings

H

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.

1 von 66
Deﬁnitionsverzeichnis

J

Literaturverzeichnis

K

BibTEX Eintrag

N

F

2 von 66

1.

Einführung
»Essentially, all models are wrong, but some are
useful.«
F
[BD87, S. 424]
Box und Draper (1987)

Das Ziel dieser Arbeit ist die Erstellung eines Codegenerators, der aus der
abstrakten Beschreibung der Spreadshirt-Api eine Client-Bibliothek erstellt.
Der Generator soll eine ﬂexible Wahl der Zielsprache bieten, wobei mit »Zielsprache« im folgenden die Programmiersprache der erzeugten Bibliothek gemeint ist. Für das Bibliotheksdesign ist eine Dsl (Domain-Speciﬁc Language)
zu realisieren, mit dem Ziel die Nutzung der Api zu vereinfachen.
Als Programmiersprache für den Generator wird Java verwendet, Php ist
die Zielsprache der Bibliothek. Eine gute Lesbarkeit, hohe Testabdeckung und
größtmögliche Typsicherheit, soweit Php dies zulässt, sind Erfolgskriterien für
die zu generierende Bibliothek.
Abbildung 1.1 stellt den schematischen Aufbau des gewünschten Generators
dar.
Spreadshirt ist eines der führenden Unternehmen für personalisierte Kleidung
und zählt zu den Social Commerce-Unternehmen. Dieser Begriﬀ beschreibt
Handelsunternehmen bei denen die aktive Beteiligung und die persönliche BeStatische Dateien

abstrakte
.
API Beschreibung

Parser

REST-API
Modell

Codegenerator
Java

Sprachenmodell
Abstrakter
Syntaxbaum

Ausgabemodul

Abbildung 1.1.: Aufbau des Generatorsystems

F

Client-Bibliothek
PHP

1. Einführung

3 von 66

Abbildung 1.2.: Spreadshirt Logo

ziehung sowie Kommunikation der Kunden untereinander im Vordergrund stehen. Spreadshirt hat Standorte in Europa und Nordamerika, der Hauptsitz ist
in Leipzig.
Dem Nutzer wird eine Online-Plattform geboten um Kleidungsstücke selber
zu gestalten oder zu kaufen, aber auch um eigene Designs, als Motiv oder in
Form von Produkten, zum Verkauf anzubieten. Zusätzlich wird jedem Nutzer
ermöglicht einen eigenen Shop auf der Plattform zu eröﬀnen und diesen auf der
eigenen Internetseite einzubinden. Derzeit gibt es rund 400.000 SpreadshirtShops mit ca. 33 Millionen Produkten. Für die Spreadshirt-Api können Kunden eigene Anwendungen schreiben, beispielsweise www.zufallsshirt.de [Pas13]
oder www.soundslikecotton.com [Ött13]. Spreadshirt bedient neben dem Endkundenauch das Großkundengeschäft als Anbieter von Druckleistungen.
Die sprd.net AG, zu der auch der Leipziger Hauptsitz gehört, beschäftigt
derzeit 450 Mitarbeiter, davon 50 in der IT.
Die zwei wichtigsten Konstanten in der Anwendungsentwicklung sind laut
[Her03] folgende:
• Die Zeit eines Programmierers ist kostbar.
• Programmierer mögen keine langweiligen und repetitiven Aufgaben.
Codegenerierung greift bei beiden Punkten an und kann zu einer Steigerung
der Produktivität führen, die durch herkömmliches schreiben von Code nicht zu
erreichen wäre.
Änderungen können an zentraler Stelle vorgenommen und durch die Generierung automatisch in den Code übertragen werden, was mit verbesserter Wartbarkeit und erhöhter Eﬃzienz einhergeht. Die gewonnenen Freiräume kann

F

1. Einführung

4 von 66

der Entwickler nutzen um sich mit den grundlegenden Herausforderungen und
Problemen seiner Software zu beschäftigen.
Durch die Festlegung eines Schemas für Variablennamen und Funktionssignaturen wird eine hohe Konsistenz über die gesamte Codebasis hinweg erreicht.
Diese Einheitlichkeit vereinfacht auch die Nutzung des Generats, da beispielsweise nicht mit Überraschungen bei den verwendeten Bezeichnern zu rechnen
ist.
Zusätzlich zu dem bereits genannten allgemeinen Nutzen einer Codegenerierungslösung, entstehen für Spreadshirt noch die folgenden Vorteile:
• Vereinheitlichung bestehender Implementierungen in Form der generierten Bibliothek
• Kapselung der Authentiﬁzierung durch Integration in Client-Bibliothek
(Abschnitt 4.3.4.2)
• Erleichterung der Api-Nutzung für externe Entwickler

1.1.

Anforderungen an die Client-Bibliothek
• Austauschbarkeit der Zielsprache
• Einfache Bedienbarkeit der Bibliothek
• gute Lesbarkeit des erzeugten Codes
• größtmögliche Typsicherheit
• hohe Testabdeckung der Bibliothek
• vollständige Generierung aller Methoden aus der Api-Beschreibung

1.2.

Typographische Konventionen dieser Bachelorarbeit
➊ – ➓:

Für Verweise auf Elemente in Listings werden diese Symbole verwendet
Klassennamen:

Namen von Klassen aus Listings oder Diagrammen werden im Text fett
hervorgehoben

F

1. Einführung

5 von 66

Schlüsselwörter :

Schlüsselwörter werden im Text kursiv hervorgehoben
Quelltext:

Zur Darstellung von Quelltext wird eine Konstantschrift verwendet

F

6 von 66

2.

Web Services
»The purpose of computing is insight, not numbers.«
F
[HH73, Vorwort]
Hamming und Hamming (1973)

In diesem Kapitel werden die Grundlagen zu HTTP, Dokumentbeschreibungssprachen, Beschreibungsformate für Webanwendungen und Rest erläutert, welche für das Verständnis der Arbeit wichtig sind. Neben Xml und Json
wird auch die Schemabeschreibungssprache Xsd behandelt. Das Ende bildet
die Einführung in Rest und Wadl.

2.1.

Adressierung
Für den Zugriﬀ auf Dienste eines Web Services werden Adressen benötigt.
Adressen im Internet sind meist nach einem bestimmten Schema aufgebaut,
üblicherweise sind dies Uris. Um Unklarheiten bei der Verwendung der Begriﬀe
Uri, Url und Urn im Verlauf der Arbeit zu vermeiden, werden Sie an dieser
Stelle deﬁniert.

Deﬁnition 1 (Uri). Ein »Uniform Resource Identiﬁer« (Uri) ist eine kompakte Zeichenkette zur Identiﬁzierung einer abstrakten oder physischen Ressource. …
Eine Ressource ist alles was identiﬁzierbar ist, beispielsweise elektronische Dokumente, Bilder, Dienste und Sammlungen von Ressourcen. (eigene Übersetzung von
[Ber+98]).

F

2. Web Services

7 von 66

Abbildung 2.1.: Diagramm zur Veranschaulichung der Teilmengenbeziehung zwischen den
Adressierungsarten, Quelle [Wik13b]

Deﬁnition 2 (Url). Der Begriﬀ »Uniform Resource Locator« (Url) bezieht sich
auf eine Teilmenge von Uris. Urls identiﬁzieren Ressourcen über den Zugriﬀsmechanismus, anstelle des Namens oder anderer Attribute der Ressource. (eigene
Übersetzung von [Ber+98]).

Deﬁnition 3 (Urn). Eine Teilmenge der Uris, die sogenannten »Uniform Resource Names« (Urns), sind global eindeutige und beständige Bezeichner für Ressourcen. Sie müssen verfügbar bleiben auch wenn die bezeichnete Ressource nicht
mehr erreichbar oder vorhanden ist. … Der Unterschied zu einer Url besteht darin,
das ihr primärer Zweck in der dauerhaften Auszeichnung einer Ressource mit einem
Bezeichner besteht. (eigene Übersetzung von [Ber+98]).

Beispiel Urls:
• http://www.spreadshirt.net/
• mailto:admin@klingt.net
Beispiel Urns:
• urn:spreadshirt:product:2648
• urn:isbn:9780131392809

F

2. Web Services

2.2.

8 von 66

HTTP

Deﬁnition 4 (Http). Das Hypertext Transfer Protocol (Http) ist ein allgemeines und zustandsloses Protokoll, zur Übertragung von Daten über ein Netzwerk,
was durch Erweiterung seiner Anfragemethoden, Statuscodes und Header für viele
unterschiedliche Anwendungen verwendet werden kann ([Fie+99, Abstract]).

Http arbeitet auf der Anwendungsschicht des Osi-Modell und ist somit unabhängig von dem zum Datentransport eingesetzten Protokoll. Über eindeutige
Uris werden Http-Ressourcen angesprochen. Dabei sendet ein Client eine
Anfrage (request) und erhält daraufhin vom Server eine Antwort (response).
Anfrage und Antwort stellt dabei eine Http-Nachricht dar, die aus den zwei
Elementen Header und Body besteht. Letzterer trägt die Nutzdaten und kann,
je nach verwendeter Http-Methode, auch leer sein.

2.2.1. Methoden
»RFC 2616, Hypertext Transfer Protocol – HTTP/1.1« ([Fie+99]) deﬁniert
einige Http-Methoden, wobei die am meisten verwendeten die folgenden sind:
• Get (Aufruf einer Webseite im Browser → Get-Request an Server)
• Put
• Post (Übermittlung von Formulardaten eines Client an Server)
• Delete
• Options
Alle bis auf Post und Options sind idempotent ([Fie+99] Kapitel 9), d.h. eine Komposition (Ausführung der Methoden hintereinander) der Methode führt
zu demselben Ergebnis wie ein einzelner Aufruf.
Methodennamen sind üblicherweise Verben die die auszuführende Aktion
beschreiben, deswegen werden HTTP-Methoden auch »verbs« genannt. Die
Deﬁnition von eigenen Methoden ist möglich.

F

2. Web Services

9 von 66

2.2.2. Header
Ein Header einer Http-Nachricht besteht aus einer Request Line (erste Zeile
des Headers) und einer Menge von Schlüssel-Wert-Paaren. Listing 2.1 zeigt
einen Beispiel-Header für die Get-Anfrage auf die Spreadshirt-Api Ressource:
http://api.spreadshirt.net/api/v1/locales.
1

GET ➊ /api/v1/locales ➋ HTTP/1.1 ➌

2

User-Agent: curl/7.29.0 ➍

3

Host: api.spreadshirt.net ➎

4

Accept: */* ➏

Listing 2.1: Http-Header

von

Get

Request

auf

Spreadshirt-Api

Ressource

http://api.spreadshirt.net/api/v1/locales

➊ Angabe der Http-Methode
➋ Ressource
➌ verwendete Http-Version
➍ User-Agent, Angabe zum Client-System, das die Anfrage versendet
➎ Host, der Server welcher die Anfrage erhält und der die Ressource ➋
verwaltet
➏ Angabe von Content-Types, die der Client als Antwort akzeptiert, in
diesem Fall eine Wildcard, also alle Typen sind als Antwort erlaubt
Nachfolgend die Response auf den soeben beschrieben Request.
1

HTTP/1.1 200 OK ➊

2

Expires: Tue, 20 Aug 2013 19:05:25 GMT

3

Content -Language: en-gb

4

Content -Type: application/xml; ➋

5

charset=UTF-8 ➌

6

X-Cache-Lookup: MISS from fish07:80

7

X-Server -Name: mem1

8

True-Client -IP: 88.79.226.66

9

Date: Tue, 20 Aug 2013 07:20:25 GMT

10

Content -Length: 1659

11

Connection: keep-alive

Listing 2.2: Http-Header von Get Response aus Spreadshirt-Api Ressource
http://api.spreadshirt.net/api/v1/locales

F

2. Web Services

10 von 66

➊ Response Line, Angabe der Http-Version am Anfang und danach der
Http-Statuscode mit Kurzbeschreibung
➋ Angabe des Content-Types des Bodys der Nachricht (hier Xml)
➌ Kodierung der Nachricht
Welche Einträge der Header einer Http-Nachricht letztendlich enthält, ist
abhängig von der Implementierung des Clients oder Servers und es können auch
jederzeit eigene Einträge, die nicht in der Http-Speziﬁkation enthalten sind,
hinzugefügt werden.
2.2.2.1. Authorization Request Header
Die Http-Speziﬁkation [Fie+99, Abschnitt 14] sieht ein Feld für Autorisierungsinformationen im Header vor. Der Feld ist folgendermaßen aufgebaut:
Authorization: credentials. Der Aufbau des Berechtigungsnachweises (engl.

»credentials«) ist nicht näher speziﬁziert und kann vom Web Service Betreiber
selbst festgelegt werden. Die Spreadshirt-Api deﬁniert einen eigenen AutorisierungsHeader (Abschnitt 4.3.4.2).

2.2.3. Body
1

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

2

<locales

3

xmlns:xlink="http://www.w3.org/1999/xlink"

4

xmlns="http://api.spreadshirt.net"

5

xlink:href="http://api.spreadshirt.net/api/v1/locales"

6

offset="0" limit="50" count="16"

7

sortField="default" sortOrder="default">

8

<locale
xlink:href="http://api.spreadshirt.net/api/v1/locales/de_DE"

9

id="de_DE"/>

10
11

...

12

<locale

13

xlink:href="http://api.spreadshirt.net/api/v1/locales/nl_BE"

14

id="nl_BE"/>

15

</locales>

Listing 2.3: Http-Body der Response aus der Get-Methode auf der Spreadshirt-ApiRessource http://api.spreadshirt.net/api/v1/locales

F

2. Web Services

11 von 66

Der Body enthält die eigentlichen Nutzdaten. Deren Format wird mit dem
Content-Type-Eintrag des Headers angegeben. Listing 2.3 zeigt den Body der
response von Listing 2.2.

2.3.

Dokumentbeschreibungsformate
In diesem Abschnitt werden die beiden von der Spreadshirt-Api verwendeten
Dokumentbeschreibungsformate, Xml und Json, behandelt. Außerdem wird
die Schemabeschreibungssprache Xml Schema Description (Xsd) eingeführt.

2.3.1. XML

Deﬁnition 5 (Xml). Die »Extensible Markup Language«, kurz Xml, ist eine Auszeichnungssprache (»Markup Language«), die eine Menge von Regeln beschreibt um Dokumente in einem mensch- und maschinenlesbaren Format zu kodieren [W3C08].

Obwohl das Design von Xml auf Dokumente ausgerichtet ist, wird es häuﬁg
für die Darstellung von beliebigen Daten benutzt [Wik13c], z.B. um diese für
die Übertragung zu serialisieren.
1

<?xml version="1.0" encoding="UTF-8" standalone="yes"?> ➊

2

<design xmlns:xlink="http://www.w3.org/1999/xlink"

3

xmlns="http://api.spreadshirt.net"

4

...>➋

5

<name>tape_recorder</name>

6

...

7

<size unit="px">
<width>3340.0</width>

8

<height>3243.0</height>

9
10

</size>

11

<colors/>➌

12

...

13

<created>

14

2013-03-30T12:37:54Z ➍

15

</created>

16

<modified>2013-04-02T11:13:02Z</modified>

F

2. Web Services

17

12 von 66

</design>➎

Listing 2.4: Die

gekürzte

Antwort

der

API-Ressource

users/userid/designs/designID als Beispiel für eine Xml-Datei

Eine valide Xml-Datei beginnt mit der Xml-Deklaration ➊. Diese enthält
Angaben über die verwendete Xml-Speziﬁkation und die Kodierung der Datei.
Im Gegensatz zu gewöhnlichen Tags wird dieses mit <? und mit ?> beendet.
Danach folgen beliebig viele baumartig geschachtelte Elemente mit einem Wurzelelement ➋. Die Elemente können Attribute enthalten und werden, wenn sie
kein leeres Element sind ➌, von einem schließenden Tag in der gleichen Stufe abgeschlossen ➎. Nicht leere Zeichenketten als Kindelement sind ebenfalls
erlaubt ➍.
Mit Hilfe von Schemabeschreibungssprachen (Abschnitt 2.4) kann der Inhalt
und die Struktur eines Dokumentes festgelegt und gegen diese validiert werden.
Der Begriﬀ Xml Schema ist mehrdeutig und wird oft auch für eine konkrete
Beschreibungssprache, die »Xml Schema Deﬁnition«, kurz Xsd, verwendet.

2.3.2. JSON

Deﬁnition 6 (Json). »JavaScript Object Notation«, kurz Json, ist ein leichtgewichtiges, textbasiertes und sprachunbhängiges Datenaustauschformat.

Es ist

von JavaScript abgeleitet und deﬁniert eine kleine Menge von Formatierungsregeln
für die transportable Darstellung (Serialisierung) von strukturierten Daten (nach
[Cro06]).

Im Gegensatz zu Xml ist Json weit weniger mächtig, es gibt z.B. keine Unterstützung für Namensräume und es wird nur eine geringe Menge an Datentypen
unterstützt (Tabelle 2.1). Durch seine einfache Struktur wird aber ein deutlich
geringerer »syntaktischer Overhead« erzeugt. Mit Json-Schema [GZ13] ist es
möglich eine Dokumentstruktur vorzugeben und gegen diese zu validieren.
Objekte werden in Json von geschweiften ➊, Arrays hingegen von eckigen Klammern begrenzt ➋. Objekte enthalten key-value-pairs (Schlüssel-WertPaare) ➌. Schlüssel sind immer Zeichenketten, die Werte dürfen von allen Ty-

F

2. Web Services

13 von 66

primitiv

strukturiert

Zeichenketten

Objekte

Ganz-, Fließkommazahlen

Arrays

Booleans
null
Tabelle 2.1.: Json Datentypen

1

{

2

"name": "tape_recorder", ➌

3

"description": "",

4

"user": { ➊
"id": "1956580",

5

"href": "http://api.spreadshirt

6
7

}, ➊

8

"resources": [ ➋

9

...
{

10

"mediaType": "png",

12

"type": "preview",

13

pen aus Tabelle 2.1 sein und beliebig tief geschachtelt werden.

11

"href": "http://image.sprea
/15513946"
},

14

...

15
16

], ➋

17

"created": "30.03.2013 ␣ 12:37:54",
...

18
19

}

Listing 2.5: Die gekürzte Antwort der Api-Ress
als Beispiel für eine Json-Datei

2.4.

XML Schemabeschreibungssprachen (XML Schema)
Xml Schema bezeichnet Xml-basierte Sprachen, mit denen sich Elemente, Attribute und Aufbau einer Menge von Xml-Dokumenten — die dem Schema
entsprechen — beschreiben lassen. Ein Xml-Dokument wird als valid gegen-

F

2. Web Services

14 von 66

über einem Schema bezeichnet, falls die Elemente und Attribute dieses Dokumentes die Bedingungen des Schemas erfüllen [Mur+05]. Neben Xsd existieren
noch weitere Schemasprachen. Diese sind für die Arbeit unwichtig und werden
daher nicht behandelt.

2.4.1. XML Schema Description (XSD)
XML Schema Description ist ein stark erweiterte Nachfolger der Dtd (Document Type Deﬁnition), derzeit speziﬁert in Version 1.1 [W3C12]. Die Syntax
von Xsd ist Xml. Damit ist die Schemabeschreibung ebenfalls ein gültiges
Xml-Dokument. Als Dateiendung wird üblicherweise .xsd verwendet.
Die Hauptmerkmale von Xsd sind nach [Kapitel 3.2 Mur+05] die folgenden:
• komplexe Typen (strukturierter Inhalt)
• anonyme Typen (besitzen kein type-Attribut)
• Modellgruppen
• Ableitung durch Erweiterung oder Einschränkung (»derivation by extension/restriction«)
• Deﬁnition von abstrakten Typen
• Integritätsbedingungen (»integrity constraints«):
unique, keys und keyref, dies entspricht den unique-, primary- und foreign-keys aus dem Bereich der Datenbanken

1

<?xml version="1.0" encoding="UTF-8" standalone="yes"?> ➊

2

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"

targetNamespace="http:

//api.spreadshirt.net" version="1.0" elementFormDefault="qualified"> ➋
3

<xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="xlink.

4

...

xsd"/> ➌

Listing 2.6: Beginn der Xsd-Datei für die Spreadshirt-Api

Eine Xsd-Datei beginnt wie jede Xml-Datei mit der Xml-Deklaration ➊.
Das Wurzelelement der Schemadeﬁnition zeigt ➋. Das Attribut xmlns:xs=
”http://www.w3.org/2001/XMLSchema” führt den Namespace-Preﬁx xs ein
und gibt außerdem an, dass die Elemente und vordeﬁnierten Datentypen (Ab-

F

2. Web Services

15 von 66

bildung 2.2) aus dem Namensraum http://www.w3.org/2001/XMLSchema verwendet werden. Durch das Attribut targetNamespace wird der Namensraum
der Elemente festgelegt, die in dieser Schemadeﬁnition deﬁniert werden. Version gibt die Xsd-Version an. Der Wert des Attributs elementFormDefault gibt
an, ob Elemente des Schemas den targetNamespace explizit angeben müssen
(»qualiﬁed«) oder ob dies implizit geschieht (»unqualiﬁed«), die Angabe ist
optional.
Externe Schemadeﬁnitionen lassen sich unter Angabe des Namensraumes und
einer Uri zu der Xsd-Datei einbinden ➌.
Xml-Schema Description erlaubt die Deﬁnition von simplen Typen (»SimpleType«) und Typen mit strukturiertem Inhalt (»ComplexType«).
1
2

<xs:simpleType name="unit">
<xs:restriction base="xs:string"> ➊
<xs:enumeration value="mm"/> ➋

3

<xs:enumeration value="px"/> ➋

4
5
6

</xs:restriction>
</xs:simpleType>

Listing 2.7: Beispiel für einen SimpleType namens »unit« der Spreadshirt-API

SimpleType-Deﬁnitionen dienen zur Beschreibung einfacher Typen wie Enumeratoren, oder Listen für Daten eines primitiven Typs. Ein Beispiel für die
Deﬁnition eines Enumerators durch einen SimpleType zeigt Listing 2.7. Der
Basisdatentyp des Enumerators wird dabei durch die Angabe des Attributs
base ➊ festgelegt. Zuordnung von Werten zu dem Enumerator zeigt ➋.
Durch einen SimpleType deﬁnierte Listen sind durch Leerzeichen separierte Strings, sie werden meist für den Wert eines Attributes einer Xml-Datei
verwendet.
1
2
3

<xs:simpleType name=colors>
<xs:list itemType="xs:string"/>
</xs:simpleType>

Listing 2.8: Beispiel für einen Listentyp deﬁniert duch einen SimpleType

1

<test>red green blue</test>}

F

2. Web Services

16 von 66

Listing 2.9: Beispielinstanz für Typ aus Listing 2.8

Die Deﬁnition eines strukturierten Typs zeigt Listing 2.10.
1
2

<xs:complexType name="abstractList" abstract="true"> ➊
<xs:sequence> ➋
<xs:element minOccurs="0" ➌ name="facets"> ➍

3

<xs:complexType> ➎

4

<xs:sequence>

5

<xs:element xmlns:tns="http://api.spreadshirt.net"

6

minOccurs="0" maxOccurs="unbounded" ref="tns:facet" ➏
/>
</xs:sequence>

7

</xs:complexType>

8

</xs:element>

9
10

</xs:sequence>

11

<xs:attribute xmlns:xlink="http://www.w3.org/1999/xlink" ref="xlink:href"/>

12

<xs:attribute type="xs:long" name="offset"/> ➑

13

<xs:attribute type="xs:string" name="query"/>

➐

14
15

...
</xs:complexType>

Listing 2.10: Beispiel für eine Schemabeschreibung
»abstractList«-Typs der Spreadshirt-API

mit

Xsd

anhand

des

Das ComplexType-Tag ➊ umschließt die Deﬁniton des strukturierten Typs.
Xml-Schema Description erlaubt das Deﬁnieren von abstrakten Typen, nur
Ableitungen davon dürfen als Instanzen in einem Dokument auftreten. Abgeleitete Typen dürfen dabei den abstrakten Typ erweitern oder einschränken
(»derivation by extension/restriction«).
Mit Reihenfolgeindikatoren ➋ kann die Ordnung von Elementen festgelegt
werden. Elemente unterhalb eines Sequence-Tags dürfen nur in der Abfolge
auftreten, in der sie deﬁniert worden sind. Das All-Tag ➍ hingegen erlaubt
das Vorkommen ohne festgelegte Reihenfolge. Der Reihenfolgeindikator Choice
erlaubt nur eines der Elemente, die unterhalb dieses Tags vorkommen.
Durch die optionale Angabe von Häuﬁgkeitsindikatoren ➌ kann festgelegt
werden wie oft ein Element an der deﬁnierten Stelle vorkommen darf. Entfällt

F

2. Web Services

17 von 66

dies, entspricht der Wert von minOccurs ”1” und maxOccurs ”1”, das heißt,
das Element darf genau einmal an dieser Stelle vorkommen.
Elemente einer Xml-Datei werden durch das gleichnamige Element ➍ im
Xsd deﬁniert. Ein Element benötigt die Angabe eines Namens und Typs. Die
Angabe des Typs kann dabei als Referenz auf die Typdeﬁnition ➏ oder als
Deﬁnition unterhalb des Element-Tags erfolgen ➎.
Attribute eines Xml-Tags werden durch das Attribute-Element deﬁniert. Dies
geschieht durch Angabe von Name und Typ ➐ oder durch eine Referenz auf
eine Attributdeﬁnition ➏.
Referenzen haben die Form Namensraumbezeicher:Elementname. Wobei mit
Elementname jedes Element der Schemabeschreibung gemeint ist, welches ein
name-Attribut besitzt. Der konkrete Namensraum eines solchen Bezeichners
wird vorher mit der Angabe eines Attributes in dieser Form eingeführt:
➋

xmlns : tns = "http://api.spreadshirt.net"
➊

➌

➊ Xml-Namespace
➋ Namensraumbezeichner
➌ Konkreter Namensraum

2.5.

RESTful Web Service
Representational State Transfer (deutsch: »Gegenständlicher Zustandstransfer«) ist ein Softwarearchitekturstil für Webanwendungen, welcher von Roy
Fielding — einer der Hauptautoren der Http-Speziﬁkation — in seiner Dissertation aus dem Jahre 2000 beschrieben wurde [Kapitel 5 Fie00, 95 ﬀ.].
Als Restful bezeichnet man dabei eine Webanwendung, die den Prinzipien
von Rest entspricht.

2.5.1. Elemente von REST
Im folgenden werden die Grundbausteine einer Rest-Anwendung erläutert.
Abschnitt 2.5.1.4 beschreibt die Komponenten, die an einer Aktion auf einer

F

18 von 66
2. Web Services

duration

dateTime

gDay
hexBinary

gMonth
ﬂoat
decimal

double

long

unsignedLong

integer
nonPositiveInteger

int

anyURI

QName

positiveInteger

nonNegativeInteger
negativeInteger

unsignedShort

unsignedInt
byte

unsignedByte

Komplexer Typ
von Liste
abgeleitet

Abgeleiteter Typ

short

Primitiver Typ

gMonthDay
base64Binary

Basis Typ

gYear

anySimpleType
gYearMonth

.
anyType

date

all complex types
time

token

boolean

normalizedString
Name
NMTOKENS

NMTOKEN

string

language
NCName
ENTITY
ENTITIES

IDREF

ID
IDREFS

.
Legende:

Abgeleitet durch
Einschränkung
Abgeleitet durch
Erweiterung/Einschränkung

Abbildung 2.2.: vordeﬁnierte Xsd Datentypen nach [W3C12] Kapitel 3

NOTATION

F

2. Web Services

19 von 66

Ressource beteiligt sind. Dieser Abschnitt basiert auf Kapitel 5.2 von [Fie00,
S. 86 ﬀ.].
2.5.1.1. Ressource
Eine Ressource stellt die wichtigste Abstraktion von Information im RestModell dar. Fielding deﬁniert eine ressource wie folgt:
»Any information that can be named can be a resource: a document
or image, […]. A resource is a conceptual mapping to a set of entities,
not the entity that corresponds to the mapping at any particular
point in time.«
Eine Ressource kann somit alle Konzepte abbilden, die sich über einen Bezeichner referenzieren lassen. Dies können konkrete Dokumente, aber auch
Dienste oder sogar Sammlungen von Ressourcen sein. Außerdem identiﬁziert
ein Ressourcenbezeichner, meist eine Uri (Abschnitt 2.5.2.1), immer dieselbe
Ressource, nicht aber deren Wert oder Zustand.
Ein Beispiel für eine Ressource in der Spreadshirt Api /users/{userid},
wobei {userid} die Identiﬁkationsnummer eines konkreten Nutzers bezeichnet.
Diese Ressource enthält dabei eine Menge von Elementen, ein Beispiel für eine
Ressource, die nur ein einziges Element enthält, ist /serverTime.
2.5.1.2. Repräsentation
Eine Repräsentation (representation) stellt den aktuellen oder den gewünschten
Zustand einer Ressource dar. Das Format der Repräsentation ist dabei unabhängig von dem der Ressource, Abschnitt 2.5.2.4. Aktionen mit Komponenten
einer Rest-Api werden durch den Austausch von solchen Repräsentationen
durchgeführt.
Im Allgemeinen wird unter einer Repräsentation nur eine Folge von Bytes
verstanden, inklusive Metainformationen, welche den Inhalt der Bytefolge klassiﬁziert, sowie Kontrolldaten, die die gewünschte Aktion oder die Bedeutung
der Anfrage beschreiben. Letztere sind meist Http-Header-Felder (Abschnitt 2.2.2),
beispielsweise um das Cachingverhalten zu ändern.

F

2. Web Services

20 von 66

1

...

2

<response>
<representation xmlns:sns="http://api.spreadshirt.net",

3

element="sns:productTypes" status="200", ➊

4
5

mediaType="application/xml"> ➋

6

<doc title="Success"/>
</representation>

7
8

...

9

</response>

Listing 2.11: Beispiel zu Metainformationen für Rest-Repräsentation aus WadlDatei der Spreadshirt-Api

Ein Beispiel für eine solche Angabe von Metainformationen ist in Listing 2.11
zu ﬁnden, ➊ zeigt dies in Form einer Typangabe und ➋ eines mediaTypeAttributes.
2.5.1.3. Konnektoren
Konnektoren stellen eine Schnittstelle für die Kommunikation mit Komponenten der Rest-Webanwendung dar. Aktionen auf Ressourcen und der Austausch
von Repräsentationen ﬁnden über diese Schnittstellen statt. Der Konnektor
bildet die Parameter der Schnittstelle auf das gewünschte Protokoll ab.
Eingangsparameter:
• Anfrage-Kontrolldaten
• Ressourcenidentiﬁzierung (Ressourcenbezeichner)
(optional)

Repräsentation der Ressource

Ausgangsparameter:
• Antwort-Kontrolldaten
(optional)

Metainformationen

(optional)

Repräsentation der Ressource

2.5.1.4. Komponenten
Ursprungsserver :

Serverseitiger Konnektor, der die angeforderten Ressourcen verwaltet. Er

F

2. Web Services

21 von 66

Konnektor

Beispiel

client

libwww

server

libwww, Apache Http-Server Api

cache

browser cache, Akamai

resolver

bind

tunnel

Socks

Tabelle 2.2.: Beispiele für Konnektoren nach [Fie00]

ist die einzige Quelle für Repräsentationen sowie der endgültige Empfänger von Änderungsanfragen an seine Ressourcen (Abschnitt 2.5.2.1)
Proxy :

Zwischenkomponente, die explizit vom Client verwendet werden kann,
aus Sicherheits-, Performance- oder Kompatibilitätsgründen
Gateway :

dient als Schnittstelle zwischen Client- und Servernetzwerk und kann
zusätzlich aus den gleichen Gründen wie der Proxy verwendet werden.
Konträr zum Proxy kann der Client aber nicht entscheiden, ob er einen
Gateway nutzen möchte.
User Client:

clientseitiger Konnektor, der die Anfrage an die Api startet und einziger
Empfänger der Antwort ist. In den meisten Fällen ist dies einfach ein
Webbrowser

2.5.2. REST-Prinzipien
Die fünf grundlegenden Rest-Prinzipien nach [Til09, 11 ﬀ.] lauten:
• Ressourcen mit eindeutiger Indentiﬁkation
• Verknüpfungen / Hypermedia
• Standardmethoden (Abschnitt 2.5.2.3)
• unterschiedliche Repräsentationen

F

2. Web Services

22 von 66

W arenkorb

Artikel

http://api.spreadshirt.net/api/v1/ baskets/84 /item/42
Ressource

Basis−U RL

Abbildung 2.3.: Beispiel-Uri, um den Artikel 42 aus dem Warenkorb 84 anzusprechen

• statuslose Kommunikation
Nachfolgend werden diese Prinzipien im Detail erläutert.
2.5.2.1. Eindeutige Identiﬁkation
Um eine eindeutige Identiﬁkation zu erreichen, wird jeder Ressource eine Uri
vergeben. Dadurch ist es möglich zu jeder verfügbaren Ressource einen Link
zu setzen (Beispiel Abbildung 2.3).
2.5.2.2. Hypermedia
Innerhalb einer Ressource kann auf Weitere verlinkt werden (Hypermedia). Als
Nebeneﬀekt der eindeutigen Identiﬁkation durch Uris sind diese auch außerhalb des Kontextes der aktuellen Anwendung gültig.
2.5.2.3. Standardmethoden
Durch die Nutzung von Standardmethoden ist abgesichert, dass eine Anwendung mit den Ressourcen arbeiten kann, vorausgesetzt, sie unterstützt diese.
Rest ist nicht auf Http beschränkt, praktisch alle Rest-Apis nutzen aber dieses Protokoll. Bei der Implementierung eines Restful Web Service ist darauf
zu achten, dass das serverseitige Verhalten dem der HTTP-Methode entspricht
(beispielsweise Idempotenz).
2.5.2.4. Repräsentationen von Ressourcen
Die Repräsentation sollte unabhängig von der Ressource sein, um die Darstellung gegebenenfalls für den Client anzupassen. Die Client-Anwendung kann

F

2. Web Services

23 von 66

dadurch mittels Query-Parameter oder als Information im Http-Header (Abschnitt 2.2.2) das gewünschte Format angeben und erhält die entsprechend
formatierte Antwort. Anhand des Content-Type-Feldes aus dem Http-Header
kann der Client das Format der Antwort überprüfen, für Json lautet dies zum
Beispiel application/json.
2.5.2.5. Statuslose Kommunikation
Es soll kein Sitzungsstatus (session-state) vom Server gespeichert werden, d.h.
jede Anfrage des Client muss alle Informationen enthalten, die nötig sind um
diese serverseitig verarbeiten zu können. Der Sitzungstatus wird dabei vollständig vom Client gehalten. Diese Restriktion führt zu einigen Vorteilen:
• Verringerung der Kopplung zwischen Client und Server
• zwei aufeinanderfolgende Anfragen können von unterschiedlichen Serverinstanzen beantwortet werden
In Summe wird dadurch eine verbesserte Skalierbarkeit erreicht.
Das Mitsenden von Statusinformationen bei jeder Anfrage wirkt sich, durch
eine erhöhte Netzwerklast, nachteilig aus.

2.6.

WADL
Die Web Application Description Language (kurz Wadl) ist eine maschinenlesbare Beschreibung einer Http-basierten Webanwendung einschließlich einer
Menge von Xml Schematas [Had06]. Die aktuelle Revision ist vom 31. Aug.
2009 [Had09a]. Im weiteren beziehe ich mich aber auf die in der SpreadshirtApi verwendeten Version, datiert am 9. November 2006. Die Unterschiede
zwischen beiden Revisionen können unter [Had09b] nachvollzogen werden.
Die Beschreibung eines Webservices durch Wadl besteht nach [Had06] im
groben aus den folgenden vier Bestandteilen (eigene Übersetzung):
Menge von Ressourcen:

Analog einer Sitemap, also die Übersicht aller verfügbaren Ressourcen

F

2. Web Services

24 von 66

Beziehungen zwischen Ressourcen:

die kausale und referentielle Verknüpfung zwischen Ressourcen

Methoden die auf Ressourcen angewendet werden können:

die von der jeweiligen Ressource unterstützten [Http]-Methoden, deren
Ein- und Ausgabe, sowie die unterstützten Formate

Ressourcenrepräsentationen:

die unterstützten Mime-Typen und verwendeten Datenschemata (Abschnitt 2.4.1)

F

2. Web Services

25 von 66

1

<?xml version="1.0" encoding="UTF-8" standalone="yes"?> ➊

2

<application xmlns="http://research.sun.com/wadl/2006/10"> ➋

3
4

<grammars> ➌
<include href="http://api.spreadshirt.net/api/v1/metaData/api.xsd">
<doc>Catalog XML Schema.</doc>

5
6

</include>

7

...

8

</grammars>

9

<resources base="http://api.spreadshirt.net/api/v1/"> ➍

10

<resource path="users/{userId}"> ➎

11

<doc>Return user data.</doc>

12

<method name="GET"> ➏

13

<doc>...</doc>

14

<request> ➐
<param

15
16

xmlns:xsd="http://www.w3.org/2001/XMLSchema"

17

name="mediaType"

18

style="query"

19

type="xsd:string">

20

<doc>...</doc>

21

</param>
...

22
23

</request>

24

<response> ➑
<representation

25
26

xmlns:sns="http://api.spreadshirt.net"

27

element="sns:user"

28

status="200"
mediaType="application/xml">

29
30

<doc title="Success"/>

31

</representation>

32

<fault status="500" mediaType="text/plain">
<doc title="Internal ␣ Server ␣ Error"/>

33

</fault>

34
35

...

36

}
...

37
38

</application>

Listing 2.12: Beispielaufbau
Beschreibung

einer

Wadl-Datei

anhand

der

Spreadshirt-Api

Die Datei beginnt mit der Angabe der Xml-Deklaration ➊. Die Attribute des
Wurzelknotens <application> enthalten namespace Deﬁnitionen, u. a. auch
den der verwendeten Wadl-Speziﬁkation ➋. Innerhalb des <grammars> Ele-

F

2. Web Services

26 von 66

ments werden die benutzten Xml Schemas angegeben ➌. Um die Ressourcen
der Webanwendung ansprechen zu können, wird noch die Angabe der Basisadresse benötigt ➍. Innerhalb des <resources> Elements ﬁndet sich die Beschreibung der einzelnen Ressourcen. Diese sind gekennzeichnet durch eine zur
Basisadresse relativen Uri ➎. In {…} eingeschlossene Teile einer Uri werden
durch den Wert des gleichnamigen request Parameters ersetzt um die Uri zu
bilden (generative Uris). Im Folgenden werden die von der Ressource unterstützten Http-Methoden beschrieben ➏, deren Anfrageparameter <request>
➐ sowie die möglichen Ausgaben der jeweiligen Methode <response> ➑.
Die Dokumentations-Tags <doc> sind für alle Xml-Elemente optional. Um
das Listing nicht unnötig zu verlängern, wurden die schließenden Tags weggelassen.
Abbildung 2.4 zeigt die baumartige Struktur einer Wadl-Datei. Die Kanten
enthalten Informationen über Kardinalität oder die Form des Elements (Deﬁnition/Referenz). Innerhalb der Elemente sind deren Attribute aufgelistet,
oder …falls diese schon aufgelistet wurden.

F

2. Web Services

27 von 66

.
application

0.
.1
resources

resource_type

base

re
fe
re

ce
ren
refe

0.

representation
id
mediaType
element
proﬁle []
status []

method

n

id
path
type
queryType

id

href

ratio

resource
resource_type

representation

decla

.*

.*

on
iti
ﬁn

0..*

0.

href

entspricht representation

de

method
include

fault

representation
nc
e

grammars

xml:lang
title

0..*

0..*

*
0..

doc

0..1

0..*

0..*

href

0..*

*
0..

0..*

0..

method

doc

param

…

…

…

0.

method
…

name
id

.*

…

0..
.*

…

0..*

0.

param

resource

*

*

…

*

0..

doc

0..*

0..*

method

param
id
name
style
type
default
path
required
repeating
ﬁxed

doc

request

…

link

0..*

nur PUT & POST
…

*
0..

representation

0..*

resource_type
rel
rev
location
index

0.
.*

value

0..*

option

response

doc

param

…

…

doc

fault

…

…

0..

*

representation

…

Abbildung 2.4.: Struktur einer Wadl-Datei, nach Kapitel 2 [Had06]

F

*

0..*

doc

0..

0..*

…

param
style=header
…

28 von 66

3.

Codegenerierung
»All problems in computer science can be solved by
another level of indirection.«
F
[WO08, Kapitel 17]
Wilson und Oram (2008)

Im folgenden Kapitel werden grundlegende Begriﬀe im Zusammenhang mit
Codegeneratoren und Datenmodellen deﬁniert, zusätzlich wird eine Übersicht
über gebräuchliche Generatorformen, dessen Aufgaben und Arten der Optimierung durch den Generator, gegeben.

3.1.

Codegeneratoren
Der Begriﬀ »Generator« ist sehr allgemein und wird für verschiedene Technologien verwendet, wie Compiler, Präprozessoren, Metafunktionen (TemplateMetaprogramming in C++), Codetransformatoren und natürlich Codegeneratoren. Generator und Codegenerator werden in diesem Kapitel synonym verwendet.
Deﬁnition 7 (Codegenerator). Ein Codegenerator ist ein Programm, welches
aus einer höhersprachigen Speziﬁkation (m. a. W.: auf einem höheren Abstraktionslevel als die zur Implementierung verwendete Programmiersprache), einer Software oder eines Teilaspektes die Implementierung erzeugt (nach [CE00]).

Folglich ist der Generator die Schnittstelle zwischen dem Modell- und Implementationsraum. Der Modellraum beinhaltet das domänenspeziﬁsche Modell.

F

3. Codegenerierung

29 von 66

Dieses Modell wird durch die höhersprachige Speziﬁkation in einer Systemspeziﬁkationssprache beschrieben. In Bezug auf einen Restful Webservice ist
beispielsweise Wadl inklusive seiner verwendeten Schemata die Speziﬁkationssprache und eine Wadl-Datei mit den konkreten Speziﬁkationen demzufolge
das domänenspeziﬁsche Modell.
Der Informationsgehalt der Speziﬁkation ist ausschlaggebend für den Grad
der zu erreichenden Automatisierung.

3.1.1. Aufgaben eines Generators
(optional)

Analyse der Speziﬁkation

1. Validieren der Speziﬁkation
2. Speziﬁkation durch Vorgabewerte vervollständigen
3. Optimierungen vornehmen
4. Implementierung erzeugen
Je nach Form der Speziﬁkation muss diese durch einen Analyse-Schritt (parsing) in die interne Darstellung des Generators überführt werden, beispielsweise
bei einem Compiler in einen Abstrakten Syntaxbaum (Abschnitt 3.2.1).

3.1.2. Vorteile für den Entwickler
Bei der Nutzung eines Codegenerierungsansatzes ergeben sich nach [Her03, S.
15] folgende Vorteile für den Entwickler:
Qualität:

Bugﬁxes und Verbesserungen werden durch das Generatorsystem in die
gesamte Codebasis propagiert.
Konsistenz:

Durch ein vorgegebenes Schema für die Schnittstellen- und Variablenbezeichner wird eine hohe Einheitlichkeit erreicht.
zentrale Wissensbasis:

Das domänenspeziﬁsche Wissen wird in dem Meta- oder auch domänenspeziﬁschen Modell gebündelt, das dem Generator als Eingabe dient. Än-

F

3. Codegenerierung

30 von 66

derungen am Modell werden durch den Generator in die gesamte Codebasis eingepﬂegt.
signiﬁkantere Designentscheidungen:

Aufgrund des verringerten Implementierungsaufwandes kann der Entwickler mehr Zeit für das Design seiner Architektur, Api etc. verwenden. Designfehlentscheidungen können durch Änderungen am Modell und
nachfolgender Regenierung korrigiert werden und bedürfen somit keiner
manuellen Korrektur aller generierten Klassen.
Die Erstellung eines Generatorsystems geht in der Regel mit einem nicht
unerheblichen Aufwand einher. Dieser sollte in Relation zum Umfang des zu
erzeugenden Codes gesehen werden. Ist der Umfang des Erzeugnisses zu gering,
kann der Aufwand zur Entwicklung einer Generatorlösung kontraproduktiv
sein.

3.1.3. Generatorformen
Die folgende Tabelle klassiﬁziert einige Generatorformen nach der Menge des
erzeugten Codes (»Tier«, zu deutsch: Stufe):

teilweise

vollständig

mehrfach

Inline-Code Expander

Tier-Generator

n-Tier Generator

Mixed-Code Generator
Partial-Class Generator
Tabelle 3.1.: Generatoren Klassiﬁkation nach Generierungsmenge

Herrington beschreibt in [Kapitel 4 Her03] die Formen aus Tabelle 3.1 so:
Inline-Code Expander :

Ein Inline-Code Expander nimmt Quellcode als Eingabe und ersetzt spezielle Mark-Up-Sequenzen durch seine Ausgabe. Die Änderungen werden
hierbei nicht in die Quelldatei übernommen, sondern meist direkt zu dem
Compiler oder Interpreter weitergeleitet.

F

3. Codegenerierung

31 von 66

Mixed-Code Generator :

Der Mixed-Code Generator arbeitet grundsätzlich wie der Inline-CodeExpander, seine Änderungen werden aber in die Quelle zurückgeschrieben.
Partial-Class Generator :

Partial-Class Generatoren erzeugen aus einer abstrakten Beschreibung
und Templates einen Satz von Klassen, diese bilden aber nicht das vollständige Programm, sondern werden durch manuell erzeugten Code vervollständigt.
Tier-Generator :

Die Arbeitsweise des Stufen- oder Tier-Generators entspricht der des
Partial-Class Generators, mit der Ausnahme, dass ein vollständiger Code
erzeugt wird, der keiner Nacharbeit bedarf.
n-Tier Generator :

Ein n-Tier Generator erzeugt neben dem eigentlichen Quellcode noch
beliebige andere Informationen, beispielsweise eine Dokumentation oder
Testfälle.
Die Entwicklung einer »Full-Domain Language« stellt die oberste Stufe der
Generatorformen dar. Eine solche Sprache ist Turing-vollständig und speziell
auf die Problemdomäne ausgerichtet.

3.1.4. Optimierung durch den Generator
Die Eﬀektivität von Optimierungen steigt mit dem Abstraktionslevel. Deshalb
ist es ratsam diese vom Generator durchführen zu lassen. Im Gegensatz zum
Compiler, der viele dieser Optimierungen auch selbst durchführt, besitzt der
Generator domänenspeziﬁsches »Wissen« und kann teilweise ohne Abhängigkeiten der Zielsprache optimieren (domain-speciﬁc optimization).

F

3. Codegenerierung

3.2.

32 von 66

Datenmodell
Das Datenmodell enthält die Informationen der Speziﬁkation und dient als
Eingabe für den Generator. Es ist somit die Basis der Codegenerierung. Westerinen u. a. deﬁnieren den Begriﬀ in [Wes+01] folgendermaßen1 :
Deﬁnition 8 (Datenmodell). Ein Datenmodell ist im Grunde die Darstellung
eines Informationsmodells unter Berücksichtigung einer Menge von Mechanismen
für die Darstellung, Organisierung, Speicherung und Bearbeitung von Daten. Das
Modell besteht aus einer Sammlung von …
• Datenstrukturen, wie Listen, Tabellen, Relationen etc.
• Operationen die auf die Strukturen angewendet werden können, wie Abfrage,
Aktualisierung, ...
• Integritätsbedingungen die gültige Zustände (Menge von Werten) odder Zustandsänderungen (Operationen auf Werten) deﬁnieren.

Bei dieser Deﬁnition wird der Begriﬀ Informationsmodell genutzt. Er beschreibt die Informationen, die im Datenmodell abgebildet werden sollen ohne
Berücksichtigung softwaretechnischer Aspekte. Das Informationsmodell stellt
somit die »natürlichen Daten« dar.
Bei einem Codegenerator entspricht das Datenmodell der internen Darstellung der Speziﬁkation. Neben den direkt in der Speziﬁkation enthaltenen Informationen kann der Generator im Analyseschritt (Abschnitt 3.1.1) beispielsweise Datenabhängigkeiten erkennen und diese zur Optimierung nutzen oder das
interne Datenmodell damit anreichern. Das Erkennen von Semantik im Eingabemodell ist aber nicht auf Datenabhängigkeiten beschränkt sondern kann
auf beliebige Beziehungen ausgeweitet werden.

3.2.1. Abstract Syntax Tree (AST)
Der Generator erzeugt aus den Elementen des Sprachenmodells (Abschnitt 4.1.4)
einen Abstract Syntax Tree. Die Bestandteile der generierten Klassen beschreiben einen Abstrakten Syntaxbaum.
1

eigene Übersetzung

F

3. Codegenerierung

33 von 66
gcd
.

.

=
.

.
. if
.==
.
.
. 0
.b

else
.
a
.

.
.gcd
.
.b

.%
.
. b
.
.a

Abbildung 3.1.: Beispiel Abstract Syntax Tree für den rekursiven euklidischen Algorithmus

Eine anschauliche Deﬁnition eines Abstract Syntax Tree bietet [Aho+06, S.
69] (eigene Übersetzung):

Deﬁnition 9 (Abstract Syntax Tree – Aho u. a.). Ein Abstrakter Syntaxbaum
ist die Darstellung eines Ausdrucks, wo jeder Knoten einen Operator und dessen
Kindknoten die Operanden repräsentieren. Im Allgemeinen kann für jedes Programmierkonstrukt ein Operator erzeugt werden, dessen semantisch bedeutsamen
Komponenten dann als Operanden gehandhabt werden.

Er ist das Endprodukt eines Parsingschrittes des Quelltextes. Im Gegensatz
zum konkreten Syntaxbaum (auch Parse Tree) enthält der Abstract Syntax Tree
keine Formatierungsspeziﬁsche Syntax (beispielsweise Klammern).

3.3.

Objektorientierte Sprachen
Ziel des Generators ist die Erzeugung von Code in einer objektorientierten Sprache. Aus diesem Grund werden die elementaren Konzepte solcher Sprachen in
diesem Abschnitt näher erläutert sowie die Besonderheiten der Generatorzielsprache (Php) beschrieben.

F

3. Codegenerierung

34 von 66

Im Gegensatz zu prozeduralen Sprachen (z.B. C), in denen ein Programm
eine Liste von Funktionen ist, wird es in objektorientierten Sprachen aus der
Interaktion von Objekten gebildet.
Objektorientierte Sprachen stellen eine Teilmenge der imperativen Sprachen
dar. Programme aus einer imperativen Sprache bestehen dabei aus einer Folge von Anweisungen (»Statements«). Anweisungen sind Befehle, formuliert
in der Syntax der Programmiersprache, beispielsweise Zuweisungen, Unterprogrammaufrufe oder Schleifen. Ausdrücke (»Expressions«) unterscheiden sich
zu Anweisungen, indem sie nebenwirkungsfrei sind und nach der Auswertung
einen Wert zurückliefern. Viele Programmiersprachen vermischen beide Konstrukte. Ein Beispiel dafür ist der Inkrement-Operator (++). Er inkrementiert
den Wert einer Variable und liefert ihn zurück, ist also nicht nebenwirkungsfrei. Ein Operator ist ein Operationssymbol der Programmiersprache mit einer
bestimmten Stelligkeit und Notation (Post-, Prä-, Inﬁx). Listing 3.1 zeigt den
Aufbau eines Ausdrucks, dargestellt durch eine Ebnf.
Ausdruck ::=

Wert
| Bezeichner
| [ Operator ] Ausdruck
| Ausdruck

[ Operator ]

| Ausdruck

Operator

Ausdruck

Listing 3.1: Aufbau eines Ausdrucks einer imperativen Programmiersprache als Ebnf
[] optional, | Auswahl, ::= Deﬁnition.

3.3.1. Elemente
Die Beschreibung der Elemente einer objektorientierten Sprache basiert auf
[PK12].
Objekte:

Sind eine elementare logische Einheit, kapselt Variablen und Methoden (Kapselung) und schützt private Daten vor äußerem Zugriﬀ (DataHiding). Sie bilden einen Namensraum und schützen davor das Änderungen an privaten Daten sich auf andere Objekte auswirken.

F

3. Codegenerierung

35 von 66

Klassen:

Klassen beschreiben die Variablen und Methoden für Objekte, die aus
ihnen erzeugt werden. Ein Objekt ist eine Instanz einer Klasse. Eine
Klasse kann ein aus ihr erzeugtes Objekt mit bestimmten Vorgabewerten
initialisieren. Objekte einer Klasse werden erzeugt oder auch instanziiert
durch den Aufruf der Konstruktormethode der Klasse. Die meisten objektorientierten Sprachen bieten Möglichkeiten der Vererbung, d.h., dass
Klassen gewisse Eigenschaften und Methoden von einer Klasse »erben«
können. Weiterhin können Klassen auch abstrakt sein, also die in ihnen
enthaltenen Klassen und Methoden sind nur Bezeichner, aber besitzen
keine Deﬁnition. Diese müssen dann von den Klassen deﬁniert werden,
die diese Abstrakten Klassen implementieren.
Methoden:

Methoden sind die Funktionen des Objektes, sie beschreiben sein Verhalten.
Felder :

Felder enthalten die Daten des Objektes. Ihr Inhalt repräsentiert den
Zustand des Objektes.
Access Modiﬁer :

Access Modiﬁer regeln den Zugriﬀ auf die Elemente eines Objektes. Die
Gebräuchlichsten sind hierbei public, private und protected. Durch
deren Verwendung wird die Kapselung von Daten erreicht. Welche Arten
der Zugriﬀskontrolle letztendlich vorhanden sind, ist abhängig von der
verwendeten Programmiersprache.
Namensräume :

Namensräume erlauben die Verwendung von gleichen Bezeichnern in unterschiedlichen Namensräumen. Wie im Punkt Objekte erwähnt, bilden
diese beispielsweise einen eigenen Namensraum. Der Zugriﬀ auf ein Element eines Objektes erfolgt über seinen Namensraum. Will man auf das
Element bar des Objektes foo zugreifen, geschieht dies z.B. in Php folgendermaßen: $foo->bar.

F

3. Codegenerierung

36 von 66

3.3.2. Typsystem
Den Begriﬀ »Typsystem« deﬁniert Markus Voelter in [Mar13, S. 253] so (eigene
Übersetzung):

Deﬁnition 10 (Typsystem). Ein Typsystem ordnet den Programmelementen
Typen zu und prüft die Konformität dieser Typen nach bestimmten vordeﬁnierten
Regeln.

Der Typ ist eine Eigenschaft eines Programmkonstruktes, ein solches Konstrukt ist z.B. eine Konstante, Variable, Methode.
Es wird zwischen zwei grundlegenden Formen von Typsystemen unterschieden, statisch und dynamisch. Das Unterscheidungskriterium ist der Zeitpunkt
der Typprüfung. Dynamische Typsysteme prüfen erst während der Laufzeit
des Programms, bei statischen Typsystemen hingegen übernimmt der Compiler diese Aufgabe. Ein statisches Typsystem erfordert in den meisten Fällen die
explizite Angabe des Typs durch den Programmierer. Programmiersprachen
mit statischen Typsystemen, welche Typinferenz bieten, können oft anhand des
Wertes eines Konstruktes seinen Typ erkennen und ersparen in diesen Fällen
dem Programmierer dessen explizite Angabe.

3.3.3. PHP
Php ist eine General Purpose Language, die aber vorwiegend auf die Entwicklung von serverseitigen Webapplikationen ausgerichtet ist. Php Skripte können in Html-Dateien eingebettet werden, welche der Server bei einer ClientAnfrage verarbeitet, die Php Elemente durch deren Ausgabe ersetzt und dem
Client zurücksendet. Die Sprache gehört somit zu den Server-Side Scripting
Languages. Die Verwendung ist aber nicht auf diesen Bereich beschränkt, denn
Php Anweisungen müssen nicht in Html eingebettet sein, sondern können auch
unabhängig davon als eigene Datei ausgeführt werden. Im Gegensatz zu statisch typisierten Sprachen wie Java muss Php zur Ausführung nicht kompiliert
werden. Php ist dynamisch typisiert und wird von einem Interpreter — dem

F

3. Codegenerierung

37 von 66

namensgebenden Hypertext Preprocessor — ausgeführt. Es werden seit Version 5.0 mehrere Programmierparadigmen unterstützt, neben imperativer- auch
objektorientierte Programmierung. Version 5.3 fügte die Unterstützung von
funktionaler Programmierung durch die Verwendung von Closures hinzu.

➊ Die Start- und Endtags eines Php-Files, wobei letzteres optional ist. Deren Funktion ist die Abgrenzung vom umliegenden Markup, beispielsweise wenn der Php-Code in eine Html Datei eingebettet ist.
➋ Php unterstützt das Importieren von Quellcodeﬁles anhand verschiedener
Befehle, in diesem Fall require_once.
➌ Nur in der Argumentliste einer Methodendeﬁnition sind Typangaben erlaubt, solange der Typ kein primitiver ist, d.h. den sprachinternen primitiven Datentypen wie beispielsweise String oder Integer entspricht.
➍ Statische Methoden, können ohne Instanz der umgebenden Klasse aufgerufen werden.

F

3. Codegenerierung

1

38 von 66

<?php ➊

2

require_once('Dto.php'); ➋

3

require_once('OperationDTO.php'); ➋

4
5

class BatchDTO

6

{
private $operations = array(); // operationDTO

7
8

function __construct(operationDTO ➌ $operations)

9

{

10

$this->operations = $operations;

11

}

12
13
14

public function getOperations()

15

{
return $operations = $this->operations;

16

}

17
18
19

public function setOperations(operationDTO $operations)

20

{
$this->operations = $operations;

21

}

22
23
24

public function toJSON()

25

{
$json = json_decode(/* BatchDTO */ $this);

26

return $json;

27

}

28
29

...

30
31
32

public static ➍ function fromXML(SimpleXMLElement $xml)

33

{

34

$operations = OperationDTO::fromXML(/* SimpleXMLElement */ $xml->

35

$BatchDTO =

36

return $BatchDTO;

operations);
new BatchDTO(/* operationDTO */ $operations);

}

37
38

...

39
40

}

41
42

?> ➊

Listing 3.2: Durch den Generator erzeugte BatchDTO Datenklasse der SpreadshirtAPI als Beispiel für eine PHP-Datei

F

39 von 66

4.

Generatorsystem für die
Spreadshirt-API
»An abstraction is one thing that represents several
real things equally well.«
F
[Dij07, zitiert von David Lorge Parnas]
Dijkstra (2007)

Nachdem in den vorangegangen Kapiteln allgemeine Grundlagen über Webservices (Kapitel 2) und Codegenerierung (Kapitel 3) behandelt wurden, werden in diesem Kapitel die konkreten Datenmodelle, der Generator und der
Aufbau der generierten Bibliothek für die Spreadshirt-Api beschrieben.

4.1.

Konkrete Datenmodelle
Neben den Datenmodellen, welche die Informationen beinhalten aus denen der
Generator ausführbaren Quellcode erzeugt, wird im folgenden Abschnitt das
im Sprachenmodell verwendete Kompositum-Muster erläutert.

4.1.1. REST-Modell
Zuerst muss die abstrakte Beschreibung der Spreadshirt-Api von der XmlForm, bestehend aus einem Wadl und einem oder mehreren Schemabeschreibungen, in ein für den Generator verarbeitbares Format überführt werden.
Die durch die Wadl-Datei beschriebene Baumstruktur muss in ein Datenmodell bestehend aus Klassen und Objekten transformiert werden. Um eﬀektiv
mit der Xml Darstellung arbeiten zu können wird diese zuerst mit einem Parser

F

4. Generatorsystem für die Spreadshirt-API

40 von 66

Abbildung 4.1.: Uml Klassendiagramm des Rest-Modells

(Anhang A.1) in ein Document Object Model (kurz Dom) überführt, welches
im Arbeitsspeicher gehalten wird und damit einen schnellen Zugriﬀ für nachfolgende Operationen darauf erlaubt. In einem nächsten Schritt wird das Dom,
welches noch viele Xml speziﬁsche Informationen enthält, auf die wesentlichen Api beschreibenden Merkmale reduziert. Im Gegensatz zu der in Abbildung 2.4 veranschaulichten Webanwendungsbeschreibung werden Referenzen
durch deren Deﬁnition im Modell ersetzt. Die Klassenamen des Datenmodells
orientieren sich an den Wadl Elementnamen.
Wurzelelement des Modells (Abbildung 4.1) ist die Klasse Application,
sie enthält Ressource-Objekte und den Basisbezeichner der Api beispielsweise
http://api.spreadshirt.net/api/v1/.

Eine Ressource-Klasse enthält eine Menge von Method-Objekten sowie einen Ressourcenbezeichner. Dieser ist relativ zum Basisbezeichner des Wurzelelements. Die Ressourcenbezeichner können Template-Parameter enthalten.

F

4. Generatorsystem für die Spreadshirt-API

41 von 66

Diese werden bei einer Anfrage durch einen konkreten Wert ersetzt. Beispielweise enthält der Bezeichner für die Ressource eines bestimmten Users
den Template-Parameter {userid}, vollständiger Ressourcenbezeichner users/{userid}. Ressourcenbezeichner werden durch die Klasse SplitPath reprä-

sentiert.
Jede Method-Klasse enthält ein Request und ein Response Objekt. Sie enthalten die nötigen Informationen für den Aufruf der Methode, beziehungsweise
über den Aufbau der Antwortnachricht.
Eine Request-Klasse enthält eine Liste von Query-Parametern sowie ein
Representation und Response Objekt.
Parameter enthält Angaben zum Style, Typ, Vorgabewert und ob dessen
Angabe »required«, also notwendig ist. Die Angabe des Typs ist eine Referenz
auf einen Typ aus einer Xml-Schemabeschreibung. Der Style gibt an wie der
Parameter übermittelt wird, als Teil der Query ?mediaType=xml, Key-Value
Pair des Http-Header oder als Template-Parameter des Ressourcenbezeichners.
Die Klasse Response enthält eine Liste mit Representation-Objekten und
Parameter-Objekten. Die Objekte vom Typ Representation enthalten die Beschreibung der Daten, die bei einer erfolgreichen Anfrage an die Ressource
zurückgesendet werden sowie die der Fehlermeldung, welche der Client anderenfalls erhält. Zwischen einer Fehlermeldung und einer erfolgreichen Anfrage
kann anhand des Werts des Http-Statuscodes unterschieden werden. Erfolgreiche Anfragen liefern in der Antwort meist einen Statuscode 200 OK oder 201
Created zurück, abhängig von der Anfragemethode. Die Response Parameter
geben Einträge im Http-Header an, welche für den Client nützliche Informationen enthalten. Legt der Client z.B. via Post auf der Ressource sessions
eine neue Api-Session an, so enthält das Feld Location des Http-Headers der
Serverantwort eine Url auf die Ressource der angelegten Session.
Die Representation-Klasse dient zur Beschreibung der Daten, welche entweder zur Api gesendet oder von dieser empfangen werden, sie besteht aus
einer Angabe des media-type, des Http-Statuscodes und eine Referenz auf
die Deﬁnition des Datentyps. Das Representation-Objekt des Request einer
Put- oder Post-Methode charakterisiert zum Beispiel den Aufbau der Da-

F

4. Generatorsystem für die Spreadshirt-API

42 von 66

ten, welche der Ressource übermittelt werden, üblicherweise im Http-Body.
Die Charakterisierung erfolgt dabei in Form einer Referenz auf einen Typ aus
einer Schemabeschreibung sowie der Angabe des media-type.

Beispielswei-

se enthält das Representation-Objekt der Put-Methode auf Ressource users/{userId}/designs/{designId} den media-type application/xml und eine

Referenz auf den Typ sns:design.
Referenzen auf Typdeklaration aus einer Schemabeschreibung werden nachfolgend im Modell durch die konkrete Deklaration des Typs aus der XmlSchemabeschreibung ersetzt, Abschnitt 4.1.3.
Ein Objekt der Doc-Klasse enthält einen Titel und eine Kurzbeschreibung
des zugehörigen Elements. Der Generator erzeugt daraus Quellcodekommentare für die Dokumentation der Bibliothek.

4.1.2. Schema-Modell
Wurzel des Schemadatenmodells ist die Klasse Schema. Ein Schema kann
Objekte vom Typ Complex- und SimpleType sowie Attribute und Element enthalten.
Xsd-Dateien erlauben das Importieren anderer Schemadeﬁnitionen, die Klasse Import ermöglicht dies im Schemamodell. Sie besitzt ein Objekt des zu
importierenden Schemas sowie eine Uri auf die zugehörige Xsd-Datei.
Primitive Schematypen werden durch die Klasse SimpleType abgebildet. Objekte dieser Klasse enthalten eine Kennzeichnung der Art des SimpleType (Enumerator, Liste, einfacher Wert) und bei Enumeratoren zusätzlich die einzelnen
Enumeratorwerte sowie die Angabe des Basisdatentyps.
Die ComplexType-Klasse repräsentiert die gleichnamigen strukturierten
Typen aus der Schemabeschreibung. Ein ComplexType kann Attribute, Elemente, Elementsequenzen und strukturierten Inhalt (ComplexContent) enthalten.
ComplexContent kann die gleichen Objekte wie ComplexType enthalten,
sowie einen Basistyp der erweitert oder eingeschränkt wird (»derivation by
extension/restriction«).

F

4. Generatorsystem für die Spreadshirt-API

43 von 66

Abbildung 4.2.: Uml Klassendiagramm des Schemadatenmodells

Attribute werden durch die gleichnamige Klasse Attribute gekapselt, sie
besitzen einen Attributnamen sowie eine Deﬁnition ihres Typs.
Elementsequenzen werden durch die Sequence-Klasse repräsentiert. Sie enthält einen Reihenfolgeindikator und die Elemente der Sequenz.
Objekte der Klasse Element besitzen einen Bezeichner sowie einen Complexoder SimpleType und optional eine Angabe der Auftrittshäuﬁgkeit. Die Klasse
ElementParameter dient nur zur Kapselung der Daten, welche an den Konstruktor der Elementklasse gegeben werden.
Durch die Klasse Namespace werden der Namensraumbezeichner und der
konkrete Namensraum eines Typs aus dem Schema gekapselt.

F

4. Generatorsystem für die Spreadshirt-API

44 von 66

<xs:element
xmlns:tns="http://api.spreadshirt.net"
type="tns:point" name="point"/>
<xs:complexType name="point">
<xs:sequence>
<xs:element
type="xs:double" name="x"/>
<xs:element
type="xs:double" name="y"/>
</xs:sequence>
<xs:attribute
xmlns:tns="http://api.spreadshirt.net"
type="tns:unit" name="unit"/>
</xs:complexType>

.
Element
. ComplexType
.
.
.Sequence

.
. Attribute

.
.
. Element Element

Abbildung 4.3.: Datentyp Point mit Gegenüberstellung im Schemamodell

4.1.3. Applikationsmodell
Das Applikationsmodell ist die Gesamtheit des Rest- und Schemamodells. Referenzen auf Typenbeschreibungen im Rest-Modell werden durch deren Deﬁnition im Schemamodell ersetzt. Dieses gemeinsame Modell dient dem Generator
als Eingabequelle.

4.1.4. Sprachenmodell
Um die gewünschte Austauschbarkeit der Zielsprache zu gewährleisten wurde
ein abstraktes Sprachenmodell entworfen welches die Konstrukte einer dateibasierten objektorientierten Programmiersprache (Abschnitt 3.3) abbildet. Die
gewünschte Zielsprache muss dabei die Klassen und Methoden des Modells implementieren sowie eine Language Factory (Abschnitt 4.2.1) bereitstellen um
vom Generator genutzt werden zu können. Um Semantik und Syntax der
Zielsprache im Modell zu trennen — abgesehen von Symbolen und Schlüsselwörtern — wird die Syntax in der Klasse LanguageVisitor (Abschnitt 4.2.1.1)
gekapselt. Das Sprachenmodell kapselt somit die Semantik der Zielsprache.
Alle Interfaces des Modells (Abbildung 4.4) erweitern das Interface Visitor.
Somit ist sichergestellt, dass alle Klassen, die diese Schnittstellen implementieren, eine accept-Methode für den LanguageVisitor bereitstellen.

F

Abbildung 4.4.: Uml Klassendiagramm des Zielsprachenmodells

4. Generatorsystem für die Spreadshirt-API

F

45 von 66

4. Generatorsystem für die Spreadshirt-API

46 von 66

Basis des Modells ist das Interface ClassFile. Es abstrahiert eine Klassendatei mit den Eigenschaften:
• Dateiname
• Namensraum
• Liste von Abhängigkeiten (Dependency-Klasse)
• Klassendeﬁnition
Die Liste von Abhängigkeiten der zu generierenden Klassen muss vorher aus
dem Eingabemodell ermittelt werden. Dies geschieht durch Analyse der in den
Elementdeﬁnitionen des Schemamodells enthaltenen Typen.
Dependency enthält das Schlüsselwort oder Methodenaufruf zum Import
einer Quellcodedatei. In Php werden solche Dateien bpsw. so importiert:
require_once("foo.php");.

Executable implementieren alle Elemente der Zielsprache die »ausführbar«
sind. Das Modell unterscheidet dabei zwischen Ausdruck und Anweisung (Abschnitt 3.3).
Das Interface CommonClass dient der Implementierung einer Klassendeﬁnition. Da das Interface selbst Statement erweitert, kann eine Klasse weitere
Klassendeﬁnitionen beinhalten. Eine Klassendeﬁnition besteht dabei aus einem
Klassename, Modiﬁers und aus einer Menge von Statements:
• DeﬁnitionStatement zur Einführung von lokalen Variablen.
• Method zur Deﬁnition von Methoden.
Das Modiﬁer-Interface deklariert Methoden um die Schlüsselwörter für Sichtbarkeitsmodiﬁkatoren (»Access Modiﬁer«) und »Non Access Modiﬁers« wie
static oder final zu erhalten.

Durch das Method-Interface kann eine Methodendeﬁnition implementiert
werden. Eine Methode beinhaltet dabei:
• Modiﬁer
• Methodenname
• Rückgabetyp
• Liste von Parametern (Parameter können dabei alle Klassen sein die Expression implementieren)

F

4. Generatorsystem für die Spreadshirt-API

47 von 66

SimpleExpression
Identiﬁer

x

+

Identiﬁer

Operator

y

Literal

/

( 1.2

Operator

∗

Operator

Literal

4 )

SimpleExpression

SimpleExpression

Group

Abbildung 4.5.: Beispiel für den Aufbau einer »Expression« im Sprachenmodell

• Block
Block kapselt eine Menge von Statements.
Operatoren der Zielsprache müssen das Interface Operator implementieren, ein Operator ist durch seine Arität (Stelligkeit), Notation und sein Symbol gekennzeichnet. Zum Beispiel ist der Dereferenzierungsoperator in Php
zweistellig, Inﬁx notiert und durch das Symbol -> gekennzeichnet.
Keywords und Symbols dienen zur Kapselung der Schlüsselwörter und
Symbole einer Sprache. Keywords enthält Methoden zur Abfrage typischer
Schlüsselworte wie class, import, new oder this. Sprachspeziﬁsche Symbole wie Verkettungs- und Scope-Operatoren oder Präﬁxe für Variablennamen
können über Methoden der Klasse Symbols vom Generator abgefragt werden.

4.1.4.1. Kompositum-Pattern im Sprachenmodell
Zweck des Composite- oder auch Kompositum-Patterns ist die Gleichbehandlung von Einzelelementen und Elementgruppierungen in einer verschachtelten
Struktur (z. B. Baum), sodass aus Sicht des Clients keine explizite Unterscheidung notwendig ist (nach [ES13, S. 102]).
Anwendung fand das Pattern an zwei Stellen im Modell, erstens in den Klassen welche Expression und zweitens, welche Statement implementieren. Ein
Beispiel für den Aufbau eines Ausdrucks durch Klassen des Interface Expression aus dem Sprachenmodell zeigt Abbildung 4.5. Von Statement abgeleitete
Klassen können ebenso eine Baumstruktur bilden. Block kann beispielsweise
selbst wieder Codeblöcke — also Statements vom Typ Block — enthalten.

F

4. Generatorsystem für die Spreadshirt-API

4.2.

48 von 66

Codegenerator
Nachdem in Abschnitt 4.1 die Datenmodelle des Generators betrachtet wurden, widmet sich dieser Abschnitt nur dem Aufbau des Codegenerators und
den dort verwendeten Entwurfsmustern, Factory (Abschnitt 4.2.1) und Visitor
(Abschnitt 4.2.1.1).
Die Aufgabe des Generators ist die Transformierung des Applikationsmodells in das Modell der Zielsprache. Als Form wurde die des Tier-Generators
gewählt, da vollständiger Code vom Generator erzeugt werden soll der keiner
Nacharbeit mehr Bedarf.

4.2.1. Language Factory
Das Factory-Pattern behandelt das Problem Familien von Objekten erzeugen
zu wollen ohne die konkreten Klassen zu speziﬁzieren, sondern nur Interfaces
festzulegen [ES13, S. 26]. Um eine Zielsprachenunabhängigkeit zu erreichen,
wird dem Generator bei der Erzeugung eine Factory übergeben die das Interface
Language Factory des Sprachenmodells implementiert.
Der Generator erzeugt Sprachelemente nur über diese Factory. Ein Aufruf
einer Factorymethode gibt ein Sprachelement der Zielsprache zurück, der Generator kennt aber nur den Interface-Typ. Für ihn ist die konkrete Implementierung somit transparent. Die Language Factory bildet damit die Schnittstelle
zwischen dem Generator und der Implementierung des Zielsprachenmodells.
4.2.1.1. Language Visitor
Eilebrecht und Starke deﬁnieren den Verwenduszweck des Patterns in [ES13,
S. 60] so:
»Dieses Pattern ermöglicht es, neue Operationen auf den Elementen
einer Struktur zu deﬁnieren, ohne die Elemente selbst anzupassen.«
Die Aufgabe des Language Visitor im Generator ist die Transformation des
Sprachenmodells in eine Zeichenketten-Darstellung. Wie in Abschnitt 4.1.4
schon erwähnt, enthält die Klasse, die das LanguageVisitor-Interface implementiert, Regeln für eine syntaktisch korrekte Ausgabe des Sprachenmodells.

F

4. Generatorsystem für die Spreadshirt-API

49 von 66

Zusätzlich können in den LanguageVisitor »code conventions« implementiert
werden, beispielsweise Einrückungstiefen, Zeilenlängen etc.

4.2.2. Ausgabemodul
Das Ausgabemodul beinhaltet Methoden zur Speicherung der Zeichenkettendarstellung aus dem Language Visitor. Üblicherweise ist dies die Speicherung
in Dateiform, es ist aber ebenso die Ausgabe auf stdout oder die Speicherung
in einer Datenbank möglich.

4.2.3. Generatorablauf
Die Abbildung 4.6 stellt den Prozess der Bibliotheksgenerierung in Diagrammform dar.
Zu Beginn steht die Analyse der Api- und Schema-Beschreibung sowie die
Überführung in die entsprechenden Datenmodelle. In einem nachgelagerten
Schritt werden diese beiden Datenmodelle zu dem Applikationsmodell zusammengeführt. Der Generator erhält dieses Modell und eine LanguageFactory als
Eingabe. Daraus wird das Zielsprachenmodell generiert, welches den zu erzeugenden Code in Form eines Abstract Syntax Tree enthält. Aus diesem Modell
erzeugt das Ausgabemodul mit Hilfe des LanguageVisitor die Bibliotheksdateien. Der LanguageVisitor enthält die syntaktischen Informationen, um aus dem
Abstract Syntax Tree gültigen Code zu erzeugen.

4.3.

Client-Bibliothek
Die generierte Client-Bibliothek lässt sich in 2 verschiedene Arten von Klassen
gliedern:
1. die Elemente und Typen aus der Xml-Schemabeschreibung repräsentieren (Datenklassen);
2. die Api-Ressourcen und deren Methoden abbilden (Ressourcenklassen).
Zusätzlich wurden für Aufgaben die keiner explizite Generierung bedürfen,
wie Http-Methodenaufrufe, manuell Klassen mit statischen Methoden erstellt.

F

Analyse
WADL-Datei

Abstrakte
.
Beschreibung
der Spreadshirt-API

Analyse
XSD-Datei

RESTModell

SchemaModell

Kombinierer

ApplikationsModell

Generator

LanguageFactory

ZielsprachenModell

Abbildung 4.6.: Ablaufdiagram des Generators

LanguageVisitor

Ausgabemodul
(File Printer)

BibliotheksDateien

Statische Dateien

F

50 von 66
4. Generatorsystem für die Spreadshirt-API

4. Generatorsystem für die Spreadshirt-API

51 von 66

Dem Generator werden die Klassen als Abhängigkeiten im Eingabemodell bekannt gegeben und an enstprechender Stelle durch ihn als Import-Anweisungen
in der Bibliothek eingefügt. Keine explizite Generierung wird benötigt wenn
der zu erzeugende Code keine oder sehr wenig variable Bestandteile enthält.

4.3.1. Datenklassen
Die Datenklassen sind die zielsprachenabhängige Repräsentation der Elemente
und Typen aus der Xml-Schemabeschreibung.
Der Name der Klasse entspricht dabei der Bezeichnung des Typs oder des
Elements. Die Variablen einer solchen Klasse sind die Attribute und Elemente
aus der Schemabeschreibung des Typs. Php bietet keine Enumeratoren, deshalb werden die einzelnen Enum-Werte als statische Variablen vom Typ string
generiert. Für alle Variablen werden außerdem Getter- und Setter-Methoden
durch den Codegenerator erzeugt.
Konstruktoren zur Erzeugung von Objekten aus den Datenklassen werden
ebenfalls vom Generator erstellt. Dabei werden die Häuﬁgkeitsindikatoren aus
der Schemabeschreibung berücksichtigt. Bei einem minOccurs-Wert größer eins
wird das Element zu den Konstruktor-Parametern hinzugefügt. Somit ist sichergestellt, dass notwendigen Angaben auch Werte zugeordnet werden.
Methoden zur De-/Serialisierung (Abschnitt 4.3.3) in eine der beiden von der
Spreadshirt-Api unterstützten Dokumentbeschreibungsformate (Json, Xml)
sind ebenfalls Bestandteil einer Datenklasse.
Listing 4.1 zeigt einen gekürzten Ausschnitt der generierten Datenklasse zum
Element Point aus der Schemabeschreibung der Spreadshirt-Api.
1
2

<?php
require_once('Unit.php');

3
4

class Point

5

{

6

private $unit; // unit

7

private $y; // double

8

private $x; // double

9
10
11

function __construct(
/* double */ $y,

F

4. Generatorsystem für die Spreadshirt-API

/* double */ $x

12

)

13
14

{
$this->y = $y;

15

$this->x = $x;

16
17

52 von 66

}

18
19

public function setUnit(
/* unit */ $unit

20

)

21
22

{
$this->unit = $unit;

23
24

}

25
26

public function toJSON()

27

{
$json = json_decode(/* Point */ $this);

28

return $json;

29
30

}

31
32

public function toXML()

33

{
$xml =

34

new SimpleXMLElement(/* Point */ '<login ␣ xmlns="http://api.

spreadshirt.net"/>');
35

$xml->addChild(/* string */ 'unit',/* unit */ $this->unit);

36

$xml->addChild(/* string */ 'y',/* double */ $this->y);

37

$xml->addChild(/* string */ 'x',/* double */ $this->x);
return $xml->asXML();

38
39

}

40
41

public static function fromXML(
/* SimpleXMLElement */ $xml

42

)

43
44

{

45

$unit = Unit::fromXML(/* SimpleXMLElement */ $xml->unit);

46

$y = $xml->y;

47

$x = $xml->x;

48

$Point =

49

$Point ->setUnit(/* unit */ $unit);
return $Point;

50
51

new Point(/* double */ $y,/* double */ $x);

}

52
53

...

54
55

public function getX()

56

{

57

return $x = $this->x;

F

4. Generatorsystem für die Spreadshirt-API

}

58

}

59
60

53 von 66

?>

Listing 4.1: Point-Klasse als (gekürztes) Beispiel für eine generierte Datenklasse

4.3.2. Ressourcenklassen
Ressourcenklassen sind die zielsprachenabhängige Abbildung der Ressourcenbeschreibungen aus WADL-Datei der Spreadshirt-Api.
Eine Ressourcenklasse beinhaltet:
➊ ein Feld, welches die Basis-Url der API beinhaltet;
➋ ein Feld in welches die komplette Url, inklusive der ersetzten TemplateParameter (Abschnitt 4.1.1), der Ressource erhält;
➌ eine Menge von Feldern, die jeweils einem Template-Parameter zugeordnet sind;
➍ einen Konstruktor, dessen Argumente den Template-Parametern entsprechen und der aus diesen und der Basis-Url die Ressourcen-Url erstellt;
➎ Abbildungen der Methoden aus der Ressourcenbeschreibung. Methodenparameter, die zur Authentiﬁzierung an der Api notwendig sind, werden
durch einen Parameter der Klasse ApiUser (Abschnitt 4.3.4.2) substituiert ➏.
Listing 4.2 beinhaltet die generierte Klasse zur Ressource users/userId/products der Spreadshirt-Api.

F

4. Generatorsystem für die Spreadshirt-API

1

54 von 66

<?php

2

require_once('Static/methods.php');

3

require_once('Static/apiUser.php');

4

/* Create or list products for user. */

5
6

class UsersUserIdProducts

7

{

8

private $baseUrl = 'http://192.168.13.10:8080/api/v1/'; // string ➊

9

public $userId; // string ➌
private $resourceUrl = ''; // string ➋

10
11
12

/*

13

public function POST( ➎

*/

14

/* array */ $parameters ,

15

/* ApiUser */ $apiUser ,
/* ProductDTO */ $productDTO

16

)

17

{

18
19

$auth = $apiUser ->getAuthentificationHeader(/* string */ 'POST',/*

20

return Methods::post(/* string */ $this->resourceUrl ,/* string */

string */ $this->resourceUrl);
$auth,/* array */ $parameters ,/* ProductDTO */ $productDTO);
}

21
22
23

/* Sample Url is:

24

public function GET( ➎

http://... */

/* array */ $parameters ,

25

/* ApiUser */ $apiUser ➏

26

)

27

{

28
29

$auth = $apiUser ->getAuthentificationHeader(/* string */ 'GET',/*

30

return Methods::get(/* string */ $this->resourceUrl ,/* string */ $auth

string */ $this->resourceUrl);
,/* array */ $parameters);
}

31
32

function __construct( ➍

33

/* string */ $userId

34

)

35

{

36
37

$this->userId = $userId;

38

$this->resourceUrl = $this->baseUrl . 'users' . '/' . $userId . '
products';
}

39

}

40
41

?>

Listing 4.2: Klasse zur Ressource users/userId/products als Beispiel für eine
Ressourcenklasse

F

4. Generatorsystem für die Spreadshirt-API

55 von 66

4.3.3. De-/Serialisierer
Um Ressourcen-Repräsentationen (Abschnitt 2.5.1.2) mit der Spreadshirt-Api
transportunabhängig austauschen zu können, müssen die strukturierten Datenklassen serialisiert werden. In umgekehrter Richtung müssen Repräsentation
aus der Api deserialisiert — also wieder in eine Datenklasse transformiert —
werden.
Die Datenklassen-Methoden zur Serialiserung und Deserialiserung besitzen
einheitliche Bezeichner, nach dem Schema toXML, toJSON, respektive fromXML,
fromJSON. Die Deserialisierer-Methoden sind statisch um das unnötige Instan-

ziieren einer Datenklasse zu vermeiden, nur um ihre Klassendarstellung aus der
serialisierten Form zu erhalten.
Beispiele für beide Arten ﬁnden sich in Listing 4.1.

4.3.4. Statische Klassen
Statische Klassen bedeutet in dem Codegenerierungskontext, dass diese manuell erstellt wurden. Die statischen Klassen enthalten Code der von anderen
Klassen gemeinsam genutzt wird und keine variablen Bestandteile enthält.
Prinzipiell werden zwei Probleme durch statische Klassen vermindert:
1. unnötige Vergrößerung des generierten Codes
2. Vermeidung des Aufwands zur Implementierung der statischen Inhalte in
das Eingabemodell des Generators
Die generierte Client-Bibliothek beinhaltet dabei zwei dieser Klassen:
1. zur Kommunikation mit der Api über Http-Methoden
2. zur Kapselung von Authentiﬁzierungsinformationen
Den Import beider Klassen zeigt Listing 4.2 in Zeile 2 und 3.
4.3.4.1. Nutzung der HTTP-Methoden
Um die generierten Ressourcenklassen nicht unnötig zu vergrößern wurde der
einheitliche Vorgang zum Aufruf der Http-Methoden in eine manuell erstellte
Klasse ausgelagert.

F

4. Generatorsystem für die Spreadshirt-API

56 von 66

Listing 4.2 zeigt in Zeile 20 und 30 den Aufruf zweier solcher Methoden aus
einer Ressourcenklasse.
4.3.4.2. API Authentiﬁzierung
In der Spreadshirt-Api sind geschützte und ungeschützte Ressourcen vorhanden.
Das zur Authentiﬁzierung eines Api-Nutzers verwendete Protokoll SprdAuth
basiert auf »Https Authorization Request Header« sowie dem »Www-Authentiﬁcate
Response Header« [BB13].
Die Spreadshirt-Api unterstüzt die Übergabe der nötigen Autorisierungsparameter als Teil der Uri-Query oder in Form des Authorization-Header. Die
erzeugte Client-Bibliothek beschränkt sich auf die Nutzung des AuthorizationHeaders, dieser besitzt folgenden Aufbau:
1

Authorization:

SprdAuth apiKey="<apikey >", ➊

2

data="<method > ␣ <url> ␣ <time>",

3

sig="SHA1(<method > ␣ <url> ␣ <time> ␣ <secret > ␣➋ )",

4

sessionId="<sessionId >" ➌

Listing 4.3: Aufbau des Spreadshirt Authentiﬁcation Header

Die Klasse ApiUser kapselt die Daten, die zur Autorisierung an der Api
nötig sind und stellt eine Methode bereit, die dem Nutzer das Erstellen des
Authorization-Headers erspart. Der Konstruktor der ApiUser-Klasse erwartet
dabei die Angabe der folgenden Parameter:
Alle Methoden, die eine Autorisation benötigen erhalten vom Codegenerator
einen Parameter vom Typ ApiUser wie ➎ in Listing 4.2 zeigt.
• UserID, die Indentiﬁkationsnummer des Spreadshirt-Nutzers
• ApiKey und Secret (➊, ➋), diese Informationen erhält der Nutzer, wenn
er sich als Api-User bei Spreadshirt registriert
• SessionID (➌), die SessionID ist in der Response der POST-Methode auf
Ressource sessions enthalten.

F

57 von 66

5.

Evaluierung
»There are two ways to write error-free programs;
only the third one works«
F
[Per82]
Perlis (1982)

In diesem Kapitel soll der Generator und die erzeugte Bibliothek gegenüber
den Anforderungen evaluiert werden. Dies geschieht für die Nutzbarkeit (Abschnitt 5.6) anhand eines einfachen Anwendungsbeispieles.

5.1.

PHP-Zielsprachenmodell
Das PHP-Zielsprachenmodell ist die Implementierung der Schnittstellen die
durch das Sprachenmodell vorgegeben sind. Eine Gegenüberstellung eines Ausschnittes einer generierten Klassendatei mit ihrer Repräsentation im Abstract
Syntax Tree der aus Elementen des Sprachenmodells gebildet wird, zeigen Abbildung 5.1 und Listing 5.1.

5.1.1. Implementierung einer Zielsprache
Um eine neue Zielsprache für den Generator zu implementieren ist es notwendig alle Interfaces des Sprachenmodells (Abschnitt 4.1.4) zu implementieren.
Methoden zum Erhalt von Schlüsselwörtern, Sichtbarkeitsmodiﬁkatoren und
Symbolen (z.B. Inkrement, Dereferenzoperator, usw.) sind in den Interfaces
Keywords, Modiﬁers und Symbols deklariert. Die Syntax der Zielsprache, sowie
der verwendete Code-Style werden durch die Implementierung des Interfaces
LanguageVisitor festgelegt.

F

58 von 66
5. Evaluierung

Import
Literal

Import

.
ClassFile

Literal

’OperationDTO.php’
AssignmentStatement

CommonClass

PrimitiveType PrimitiveType
’Dto.php’
’BatchDTO’

Modiﬁers
’static’ Identiﬁer

DeﬁnitionStatement

’array’

Operator MethodInvocation

Modiﬁers ’=’

Variable
’operations’
’private’
’fromXML’
’public’

Comment
’SimpleXMLElement’

’xml’

Block

’MethodInvocation’

AssignmentStatement
’Operator’

SimpleExpression

Identiﬁer

’fromXML’

Identiﬁer

’::’

Operator

’operations’

Identiﬁer

’operations’
’xml’

’->’
Comment
’SimpleXMLElement’

Abbildung 5.1.: Darstellung von BatchDTO aus Listing 5.1 im Sprachenmodell [Klasse, Zeichenkette]

F

5. Evaluierung

59 von 66

Neben den Interfaces des Sprachenmodells müssen auch die statischen Klassen in der Zielsprache implementiert werden.
1

<?php

2

require_once('Dto.php');

3

require_once('OperationDTO.php');

4
5

class BatchDTO

6

{

7

private $operations = array(); // operationDTO

8

...

9

public static function fromXML(
/* SimpleXMLElement */ $xml

10

)

11

{

12

$operations = OperationDTO::fromXML(/* SimpleXMLElement */ $xml->

13

operations)
14

;

...
}

15

...

16

}

17
18

?>

Listing 5.1: Ausschnitt der generierten Datenklasse BatchDTO

5.1.2. Codestyle/Lesbarkeit
Um den erzeugten Code möglichst lesbar zu gestalten, wurden folgende Konventionen im LanguageVisitor implementiert:
• erhöhen der Einrückungstiefe innerhalb jedes Codeblockes
• Zeilenumbruch vor jedem Block-Begrenzer ({, })
• Zeilenumbruch vor jedem Parameter in einer Funktionsdeﬁnition (Listing 4.2, Zeile 13 und folgende)

5.2.

Typsicherheit
Php bietet durch seine dynamische Typisierung leider keine Typprüfung zur
Compilezeit. Da dem Generator die erwarteten Typen bekannt sind, werden
die Typnamen an entsprechender Stelle im Code durch ein Block-Kommentar

F

5. Evaluierung

60 von 66

eingefügt (wie u.a. in listing 4.2 und Listing 4.1 zu sehen). Somit ist zumindest eine manuelle Prüfung der zu übergebenden Typen für den Nutzer der
Bibliothek möglich.
Durch die Implementierung speziell formatierter Kommentare — beispielsweise /** @var [typename] */ in IntelliJ Idea — kann eine Typprüfung durch
die Ide ermöglicht werden. Um sich nicht auf eine spezielle Ide festlegen zu
müssen, werden derzeit normale Block-Kommentare an dieser Stelle erzeugt.

5.3.

Generierung von Tests für die erzeugte Bibliothek
Die Generierung von Tests für die erstellte Bibliothek ist derzeit noch nicht implementiert. Ein Testszenario für die erzeugten Datenklassen wäre die Prüfung
auf Gleichheit vor und nach der Serialisierung. Zur Überprüfung der Ressourcenklassen werden erfolgreiche Tests der Datenklassen vorausgesetzt, da die
Testdaten aus den Datenklassen erstellt werden. Die erfolgreiche Ausführung
der Methoden einer Ressourcenklassen lässt sich über deren Statuscode überprüfen.
Eine andere Vorgehensweise zur Prüfung der erzeugten Bibliothek wäre die
manuelle Erstellung von Tests basierend auf typischen Anwendungsfällen, wie
dem Anlegen neuer Designs oder dem Erstellen neuer Produkte. Besser wäre
dieses Vorgehen zusätzlich zu automatisch erzeugten Tests durchzuführen um
eine möglichst hohe Abdeckung zu erreichen.

5.4.

Metriken
Die Erzeugung der Client-Bibliothek erfolgt nur bei Änderungen an der SpreadshirtApi, weshalb keine besonderen Anforderungen an die Dauer des Generierungsvorganges gestellt wurden. Um aus der WADL-Datei der Spreadshirt-API
[AG13] die Bibliothek zu generieren, benötigt der Codegenerator:
• 23.1s, falls die Api-Beschreibung vom Server generiert werden muss.
• 1.25s, falls die Api-Beschreibung gecached ist.

F

5. Evaluierung

61 von 66

Dateien

Zeilen

Zeichen

Datenklassen

192

17455

38550

Ressourcenklassen
∑

97

3730

11079

289

21185

49629

Tabelle 5.1.: Metriken zur Menge des generierten Codes (ohne statische Klassen)

Die Werte wurden über drei Generierungsvorgänge gemittelt und auf folgenden System erfasst:
• Intel® Core™ i5-2520M CPU
• 8GB DDR3 RAM
• 256GB Samsung® 830 SSD (ext4)
• Linux Kernel 3.8.0-31-generic (x64)
• Oracle® Java™ SE Runtime Environment (build 1.7.0_40-b43)
Der Großteil der Zeit wird für den Verbindungsaufbau mit dem Server und
dem anschließenden Transfer der Api-Beschreibung verbraucht.
Tabelle 5.1 zeigt den Umfang, der aus der Api-Beschreibung mit Stand vom
17. September 2013, erzeugten Bibliothek. Das Kommando zur Ermittlung
der Werte aus Tabelle 5.1 lautet:
find data/ resources/ -type f -name *.php -exec wc

+

Jede erzeugte Datei erhält dabei eine Klasse. Die Gesamtheit aller in [AG13]
beschriebenen Ressourcen entsprechen der Anzahl der generierten Ressourcenklassen (97). Somit ist die Anforderung erfüllt alle Methoden aus der ApiBeschreibung zu generieren.

5.5.

Leistungsbewertung
Im folgenden soll eine typischer Arbeitsablauf mit der Client-Bibliothek gezeigt
werden. Der Client sollte zum Einstieg ein Objekt der Datenklasse LoginDTO
anlegen ➊ und seine Login-Informationen eintragen, dies wird benötigt um über
die Ressourcenklasse Sessions auf der gleichnamigen Api-Ressource eine neue

F

5. Evaluierung

62 von 66

Sitzung (»Session«) anzulegen. Die Response der Session-Ressource enthält
eine Uri auf die Ressource der angelegten Sitzung. Diese Uri enthält die
SessionID welche durch ➌ aus der Uri extrahiert wird.
Nun sind alle nötigen Informationen vorhanden um ein Objekt der Klasse
ApiUser anzulegen ➍, welches die Authentiﬁzierungsinformationen für gesicherte Ressourcen der Spreadshirt-Api enthält.
Nun kann über die Bibliotheksklassen auch auf geschützte Api-Ressourcen
zugegriﬀen werden, in diesem Fall werden beispielsweise die Produkte eines bestimmten Users abgefragt. Entegegen den vorherigen Aufrufen von Methoden
der Ressourceklassen wird ein Parameter-Array erzeugt ➎ um den mediaType
der Response festzulegen. Vor dem Zugriﬀ auf die Ressource muss noch die
entsprechende Ressourcenklasse instanziiert werden ➏.
1

<?php

2
3

require_once("data/LoginDTO.php");

4

require_once("Static/apiUser.php");

5

require_once("resources/UsersUserId.php");

6

require_once("resources/UsersUserIdProducts.php");

7

require_once("resources/Sessions.php");

8
9

$loginDTO = new LoginDTO(); ➊

10

$loginDTO ->setUsername("username");

11

$loginDTO ->setPassword("password");

12

$resource = new Sessions();

13

$session = $resource ->POST(null, $loginDTO); ➋

14

$sessionId = preg_replace('/.*\//',"",$session['header']['Location']); ➌

15
16

$apiUser = new ApiUser("userId", "apiKey", "secret", $sessionId); ➍

17
18

$parameters = array("mediaType"=>"json"); ➎

19

$resource = new UsersUserIdProducts($userId); ➏

20

$products = $resource ->GET($parameters , $apiUser); ➐

21
22

?>

Listing 5.2: Beispiel für eine Interaktion mit der Spreadshirt-API über die generierte
Client-Bibliothek (Authentiﬁzierungsinformationen wurden anonymisiert)

Verhältnis Bibliothekscode, manuell erstellter Code: xx%

F

5. Evaluierung

5.6.

63 von 66

Nutzbarkeit
Quellcodedateien die Bibliotheksfunktionen nutzen müssen im Wurzelverzeichnis dieser Bibliothek liegen. Dies ist damit begründet das der Php-Interpreter
bei Importanweisungen mit relativen Pfaden, den aktuellen Pfad der ausgeführten Datei als Basis nimmt.
Der Aufruf des Generators erfolgt über die Kommandozeile. Als einziges Argument wird die Url zur Wadl-Datei erwartet. Beispiel:
java api-client-libs.jar http://api.spreadshirt.net/api/v1/metaData/api.wadl

Der Ausgabepfad der erzeugten Bibliothek ist relativ zum Aufrufpfad des Generators: ./generated/php.
Derzeit ist die Bibliothek noch eingeschränkt nutzbar, da die De-/Serialisier
von strukturierten Typen noch nicht fehlerfrei generiert werden. Die Informationen, die nötig sind um Datenklassen verlustfrei zu serialisieren und wieder
zu deserialisieren sind im Schema-Modell (Abschnitt 4.1.2) vorhanden. Deshalb muss der Algorithmus im Codegenerator zur Erzeugung dieser Methoden
überarbeitet werden.

F

64 von 66

6.

Schlussbetrachtung
»Der Zauber steckt immer im Detail.«
F
[Fon+94]
Fontane u. a. (1994)

6.1.

Ausblick
Der in dieser Arbeit dokumentierte Codegenerator bietet mehrere Ansatzpunkte für Erweiterungen oder Verbesserungen:
• Generierung eines Fluent-Interface Pattern. Dieses Entwurfsmuster wurde von Fowler in [Fow10] beschrieben und basiert auf der Technik des
»method-chaining«, also der Hintereinanderausführung von Methoden,
wobei jede Methode mit dem Resultat der vorangegangen arbeitet.
• Die Erzeugung von Parameterobjekten welche die Parametersignatur der
jeweiligen Methode repräsentieren, wird verhindert das der Nutzer unerlaubte Parameter an eine Methode übergibt. Dies ist derzeit möglich,
da vom Nutzer beliebiger Inhalt die Arrays eingetragen werden kann, die
zur Übermittlung der Methodenparameter dienen.
• Implementieren weiterer Sprachenmodelle, beispielsweise zur Generierung
einer Java-Bibliothek.
• Erzeugen von Tests durch den Generator um die generierte Bibliothek
automatisch prüfen zu können.

F

6. Schlussbetrachtung

6.2.

65 von 66

Fazit
Der entwickelte Codegenerator zur Erzeugung einer Client-Bibliothek für die
Spreadshirt-Api …
Vorteile die sich daraus ergeben…
Probleme bei der Erstellung…

F

A von N

A. Implementierung
»Hofstadter’s Law: It always takes longer than you
expect, even when you take into account
Hofstadter’s Law.«
F
[Hof99, S. 152]
Hofstadter (1999)

Dieses Kapitel begründet die Entscheidung für den gewählten Xml-Parser
anhand eines Vergleichs verschiedener Parser-Modelle in Java.

A.1. XML-Parser
Um mit der abstrakten Beschreibung der Spreadshirt-Api arbeiten zu können,
muss diese zuerst in das interne Datenmodell überführt werden. Diese liegt in
Xml-basierter Form vor, welche in Kapitel 2 näher beschrieben wurde. Folglich
wird ein Xml-Parser für die Verarbeitung der Beschreibungsformate benötigt.
Die »Java Api for Xml Processing« kurz Jaxp abstrahiert die Parserschnittstelle von der eigentlichen Implementierung. Jaxp ist dabei keine einzelne Api,
sondern es beschreibt Schnittstellen für folgende vier Xml-Parser Modelle:
Dom:

»Document Object Model«-Parser überführen das Xml-Dokument in ein
baumartiges Objektmodell, welches vollständig im Arbeitsspeicher liegt.
Sax: Die »Simple Api for Xml« basierten sogenannten Push-Parser verarbei-

ten das Xml-Dokument seriell und eventbasiert. Ein Event ist hierbei
beispielsweise ein öﬀnendes oder schließendes Xml-Element.
StAX :

Auf »Streaming Api for Xml« basierende sogenannte Pull-Parser arbeiten ebenso wie bei Sax seriell und eventbasiert, können aber im Gegensatz dazu die Erzeugung von Events selber steuern.

F

A. Implementierung

B von N

TrAX :

Die »Transformation Api for Xml« bietet eine Schnittstelle, mit der sich
Xml-Dokumente durch Extensible Stylesheet Language Transformations
( Xslt) in Java transformieren lassen.
Tabelle A.1 enthält eine Übersicht zu den Parsing-Konzepten, ausgenommen
TrAX, da diese Api vorwiegend für die Modiﬁkation von Xml-Dateien gedacht
ist.
Bei dem zu entwickelnden Codegenerator sind der Speicherverbrauch und die
verwendete Cpu-Zeit kein Teil der nichtfunktionalen Anforderungen. Somit ﬁel
die Entscheidung auf einen Dom-Parser. Dieser lässt sich durch das komplett
im Speicher gehaltene Objektmodell mit geringem Aufwand verwenden. Durch
Jaxp ist die Implementierung transparent und es wird die im Jdk enthaltene
Standart Dom-Parser Implementierung verwendet.

DOM

SAX

StAX

In-Memory Tree

push-streaming

pull-streaming

Speicherverbrauch

hoch

gering

< Dom

Prozessorlast

hoch

gering

gering

beliebig

seriell

seriell

niedrig

hoch

mittel

ja

nein

ja

API-Typ

Elementzugriﬀ
Nutzerfreundlichkeit
XML schreiben

Tabelle A.1.: Übersicht über die verschiedenen Xml-Parsing Konzepte in Jaxp

F

C von N

Glossar
Api: Application Programming Interface (deutsch: »Schnittstelle zur Anwen-

dungsprogrammierung«) speziﬁziert, wie Softwarekomponenten über diese Schnittstelle miteinander interagieren können. III, IV, 2–4, 9–11, 13,
14, 19–23, 25, 30, 39–41, 49, 51, 53, 55, 56, 60–62, 65, A, B, H
Dsl: Domain Speciﬁc Language (deutsch: »Domänenspeziﬁsche Sprache«) ist

eine Programmiersprache die nur auf eine bestimmte Domäne oder auch
Problembereich optimiert ist . 2, E
Dtd:

Document Type Deﬁnition, manchmal auch Data Type Deﬁnition ist eine
Menge von Angaben, die einen Dokumenttyp beschreiben. Es werden
konkret Element- und Attributtypen, Entitäten und deren Struktur beschrieben. Die bekanntesten Schemasprachen für XML-Dokumente sind
XSD und RelaxNG. 14, siehe Xsd
Http:

Das Hypertext Transfer Protocol ( Http) ist ein allgemeines und zustandsloses Protokoll, zur Übertragung von Daten über ein Netzwerk, was durch
Erweiterung seiner Anfragemethoden, Statuscodes und Header für viele
unterschiedliche Anwendungen verwendet werden kann ([Fie+99, Abstract]) . 8–10, 17, 19, 21–24, 26, 41, 42, 49, 55, 56, H, J
Json:

JavaScript Object Notation, kurz Json, ist ein leichtgewichtiges, textbasiertes und sprachunbhängiges Datenaustauschformat. Es ist von JavaScript abgeleitet und deﬁniert eine kleine Menge von Formatierungsregeln
für die transportable Darstellung (Serialisierung) von strukturierten Daten (nach [Cro06]). 6, 11–13, 23, 51, G, H, J, siehe Xml
Mime:

Multipurpose Internet Mail Extensions dienen zu Deklaration von Inhalten (Typ des Inhalts) in verschiedenen Internetprotokollen . 24
Osi-Modell:

Das Osi-Modell (»Open Systems Interconnection«) ist ein Konzeptuelles

F

Glossar

D von N

Modell, dass Funktionalitäten von Netzwerkprotokollen durch die Aufteilung in Abstraktionsschichten beschreibt und vereinheitlicht [Wik13a] .
8
Rest:

Representational State Transfer (deutsch: »Gegenständlicher Zustandstransfer«) ist ein Softwarearchitekturstil für Webanwendungen, welcher
von Roy Fielding in seiner Dissertation [Fie00] beschrieben wurde. Die
Daten liegen dabei in eindeutig addressierbaren resources vor. Die Interaktion basiert auf dem Austausch von representations – also ein Dokument was den aktuellen oder gewünschten Zustand einer resource beschreibt. Beispiel-URL für das Item 84 aus dem Warenkorb 42:
http://api.spreadshirt.net/api/v1/baskets/84/item/42 . 6, 17, 19–
22, 40, 44, F, H
Restful:

Als RESTful bezeichnet man einen Webservice der den Prinzipien von
REST entspricht. IV, 17, 22, 29, siehe Rest
Uri: Ein »Uniform Resource Identiﬁer« (Uri) ist eine kompakte Zeichenkette

zur Identiﬁzierung einer abstrakten oder physischen Ressource. … Eine Ressource ist alles was identiﬁzierbar ist, beispielsweise elektronische
Dokumente, Bilder, Dienste und Sammlungen von Ressourcen. (eigene
Übersetzung von [Ber+98]).. D, 6–8, 15, 19, 22, 26, 42, 56, 62, F, J
Url:

Der Begriﬀ »Uniform Resource Locator« (Url) bezieht sich auf eine Teilmenge von Uris. Urls identiﬁzieren Ressourcen über den Zugriﬀsmechanismus, anstelle des Namens oder anderer Attribute der Ressource.
(eigene Übersetzung von [Ber+98]).. D, 6, 7, 41, 53, 63, J, siehe Uri
Urn:

Eine Teilmenge der Uris, die sogenannten »Uniform Resource Names«
(Urns), sind global eindeutige und beständige Bezeichner für Ressourcen.
Sie müssen verfügbar bleiben auch wenn die bezeichnete Ressource nicht
mehr erreichbar oder vorhanden ist. … Der Unterschied zu einer Url
besteht darin, das ihr primärer Zweck in der dauerhaften Auszeichnung
einer Ressource mit einem Bezeichner besteht. (eigene Übersetzung von
[Ber+98]).. D, 6, 7, J, siehe Uri
Wadl:

Web Application Description Language ist eine maschinenlesbare Be-

F

Glossar

E von N

schreibung einer HTTP-basierten Webanwendung. 6, 20, 23, 25–27, 29,
39, 40, 63, F, H, siehe Xml
Xml:

Die Extensible Markup Language, kurz Xml, ist eine Auszeichnungssprache (»Markup Language«), die eine Menge von Regeln beschreibt um
Dokumente in einem mensch- und maschinenlesbaren Format zu kodieren [W3C08] . 6, 10–17, 23, 25, 26, 39–42, 49, 51, A, B, G, H, J
Xsd:

XML Schema Description, auch nur XML Schema ist eine Schemabeschreibungssprache und enthält Regeln für den Aufbau und zum Validieren einer XML-Datei. Die Beschreibung ist selbst wieder eine gültige
XML-Datei. 6, 11, 12, 14–18, 42, F, H, siehe Xml
Abstract Syntax Tree:

Ein Abstrakter Syntaxbaum ist die Baumdarstellung einer abstrakten Syntaktischen Struktur von Quellcode einer Programmiersprache. Jeder
Knoten des Baumes kennzeichnet ein Konstrukt des Quellcodes. Der AST
stellt für gewöhnlich nicht alle Details des Quelltextes dar, beispielsweise
formatierende Element wie etwa Klammern werden häuﬁg weggelassen .
32, 33, 49, 57, F
Closure :

Eine Closure ist eine Funktion, welche die besondere Eigenschaft besitzt
auf Variablen aus ihrem Entstehungskontext zugreifen zu können. Die
Funktion wird meist in einer Variablen gespeichert um den Zugriﬀ darauf
zu sichern . 37
General Purpose Language:

Eine General Purpose Language bezeichnet eine Programmiersprache welche für den Einsatz in den verschiedensten Anwendungsbereichen verwendet kann, im Gegensatz zu einer Dsl, welche nur auf einen speziellen
Bereich beschränkt ist . 36

F

F von N

Abbildungsverzeichnis
1.1. Aufbau des Generatorsystems . . . . . . . . . . . . . . . . . . .
1.2. Spreadshirt Logo . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1. Diagramm zur Veranschaulichung der Teilmengenbeziehung zwischen den Adressierungsarten, Quelle [Wik13b] . . . . . . . . .
2.2. vordeﬁnierte Xsd Datentypen nach [W3C12] Kapitel 3 . . . . .
2.3. Beispiel-Uri, um den Artikel 42 aus dem Warenkorb 84 anzusprechen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4. Struktur einer Wadl-Datei, nach Kapitel 2 [Had06] . . . . . .

2
3
7
18
22
27

3.1. Beispiel Abstract Syntax Tree für den rekursiven euklidischen
Algorithmus . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

33

4.1.
4.2.
4.3.
4.4.
4.5.
4.6.

Uml Klassendiagramm des Rest-Modells . . . . . . . . . . . .
Uml Klassendiagramm des Schemadatenmodells . . . . . . . .
Datentyp Point mit Gegenüberstellung im Schemamodell . . .
Uml Klassendiagramm des Zielsprachenmodells . . . . . . . . .
Beispiel für den Aufbau einer »Expression« im Sprachenmodell
Ablaufdiagram des Generators . . . . . . . . . . . . . . . . . .

40
43
44
45
47
50

5.1. Darstellung von BatchDTO aus Listing 5.1 im Sprachenmodell
[Klasse, Zeichenkette] . . . . . . . . . . . . . . . . . . . . . . .

58

F

G von N

Tabellenverzeichnis
2.1. Json Datentypen . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2. Beispiele für Konnektoren nach [Fie00] . . . . . . . . . . . . . .

13
21

3.1. Generatoren Klassiﬁkation nach Generierungsmenge . . . . . .

30

5.1. Metriken zur Menge des generierten Codes (ohne statische Klassen) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

61

A.1. Übersicht über die verschiedenen Xml-Parsing Konzepte in Jaxp B

F

H von N

Listings
2.1. Http-Header von Get Request auf Spreadshirt-Api Ressource
http://api.spreadshirt.net/api/v1/locales . . . . . . . . .
9
2.2. Http-Header von Get Response aus Spreadshirt-Api Ressource
9
http://api.spreadshirt.net/api/v1/locales . . . . . . . . .
2.3. Http-Body der Response aus der Get-Methode auf der SpreadshirtApi-Ressource http://api.spreadshirt.net/api/v1/locales
10
2.4. Die gekürzte Antwort der API-Ressource users/userid/design11
s/designID als Beispiel für eine Xml-Datei . . . . . . . . . . .
2.5. Die gekürzte Antwort der Api-Ressource users/userid/designs/designID als Beispiel für eine Json-Datei . . . . . . . . . . .
13
2.6. Beginn der Xsd-Datei für die Spreadshirt-Api . . . . . . . . . . 14
2.7. Beispiel für einen SimpleType namens »unit« der Spreadshirt-API 15
2.8. Beispiel für einen Listentyp deﬁniert duch einen SimpleType . . 15
2.9. Beispielinstanz für Typ aus Listing 2.8 . . . . . . . . . . . . . . 15
2.10. Beispiel für eine Schemabeschreibung mit Xsd anhand des »abstractList«Typs der Spreadshirt-API . . . . . . . . . . . . . . . . . . . . . 16
2.11. Beispiel zu Metainformationen für Rest-Repräsentation aus WadlDatei der Spreadshirt-Api . . . . . . . . . . . . . . . . . . . . . 20
2.12. Beispielaufbau einer Wadl-Datei anhand der Spreadshirt-Api
Beschreibung . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.1. Aufbau eines Ausdrucks einer imperativen Programmiersprache
als Ebnf . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.2. Durch den Generator erzeugte BatchDTO Datenklasse der SpreadshirtAPI als Beispiel für eine PHP-Datei . . . . . . . . . . . . . . . 38
4.1. Point-Klasse als (gekürztes) Beispiel für eine generierte Datenklasse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2. Klasse zur Ressource users/userId/products als Beispiel für
eine Ressourcenklasse . . . . . . . . . . . . . . . . . . . . . . .
4.3. Aufbau des Spreadshirt Authentiﬁcation Header . . . . . . . .
5.1. Ausschnitt der generierten Datenklasse BatchDTO . . . . . . .

F

51
54
56
59

Listings

I von N

5.2. Beispiel für eine Interaktion mit der Spreadshirt-API über die
generierte Client-Bibliothek (Authentiﬁzierungsinformationen wurden anonymisiert) . . . . . . . . . . . . . . . . . . . . . . . . . 62

F

J von N

Deﬁnitionsverzeichnis
1.
2.
3.
4.
5.
6.

Deﬁnition
Deﬁnition
Deﬁnition
Deﬁnition
Deﬁnition
Deﬁnition

(Uri) .
(Url) .
(Urn) .
(Http)
(Xml) .
(Json) .

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

6
7
7
8
11
12

7.
8.
9.
10.

Deﬁnition
Deﬁnition
Deﬁnition
Deﬁnition

(Codegenerator) . . . . . . . . . .
(Datenmodell) . . . . . . . . . . .
(Abstract Syntax Tree – Aho u. a.)
(Typsystem) . . . . . . . . . . . . .

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

28
32
33
36

F

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

.
.
.
.
.
.

K von N

Literaturverzeichnis
[AG13]

sprd.net AG. WADL-Datei der Spreadshirt-API. 30. Sep. 2013.
url: http://api.spreadshirt.net/api/v1/metaData/api.wadl.

[Aho+06]

Alfred V. Aho u. a. Compilers: Principles, Techniques, and Tools
(2nd Edition). Boston, MA, USA: Addison-Wesley Longman Publishing Co., Inc., 2006. isbn: 0321486811.

[BB13]

Martin Breest und Karsten Breit. Spreadshirt-API Security. 14. Sep.
2013. url: http://developer.spreadshirt.net/display/API/
Security.

[BD87]

G.E.P. Box und N.R. Draper. Empirical model-building and response surfaces. Wiley series in probability and mathematical statistics:
Applied probability and statistics. Wiley, 1987. isbn: 9780471810339.

[Ber+98]

Tim Berners-Lee u. a. Uniform Resource Identiﬁers (URI): Generic
Syntax. Aug. 1998. url: http://www.ietf.org/rfc/rfc2396.txt
(besucht am 30. 09. 2013).

[CE00]

K. Czarnecki und U. Eisenecker. Generative programming: methods, tools, and applications. Addison Wesley, 2000. isbn: 9780201309775.

[Cro06]

Douglas Crockford. RFC 4627 - The application/json Media Type for JavaScript Object Notation (JSON). IETF. Juli 2006. url:
http://tools.ietf.org/html/rfc4627.

[Dij07]

Edsger W. Dijkstra. »Forum«. In: Commun. ACM 50.6 (Juni 2007).
Hrsg. von Diane Crawford, S. 7–9.

[ES13]

Karl Eilebrecht und Gernot Starke. Patterns kompakt. Springer
Vieweg, 2013. isbn: 978-3-642-34717-7.

[Fie00]

Roy Thomas Fielding. »Architectural styles and the design of networkbased software architectures«. AAI9980887. Diss. 2000. isbn: 0599-87118-0.

[Fie+99]

R. Fielding u. a. »RFC 2616, Hypertext Transfer Protocol – HTTP/1.1«.
In: (1999). url: http://www.ietf.org/rfc/rfc2616.txt.

[Fon+94]

T. Fontane u. a. Briefe an Georg Friedlaender. Insel Taschenbuch.
Insel, 1994.

F

Literaturverzeichnis

L von N

[Fow10]

Martin Fowler. Domain-Speciﬁc Languages. Addison-Wesley Signature Series (Fowler). Pearson Education, 2010. isbn: 9780131392809.

[GZ13]

F. Galiegue und K. Zyp. JSON Schema: core deﬁnitions and terminology. 31. Jan. 2013. url: http://tools.ietf.org/html/draftzyp-json-schema-04.

[Had06]

Sun Microsystems Inc. Hadley Marc J. Web Application Description Language (WADL). abgerufen am 21.06.2013. 9. Nov. 2006.
url: https://wadl.java.net/wadl20061109.pdf.

[Had09a]

Marc Hadley. Web Application Description Language – Changes
since November 2006 Publication. 31. Aug. 2009. url: http : / /
www.w3.org/Submission/wadl.

[Had09b]

Marc Hadley. Web Application Description Language – Changes
since November 2006 Publication. 31. Aug. 2009. url: http : / /
www.w3.org/Submission/wadl/#x3-41000D.1.

[Her03]

J. Herrington. Code Generation in Action. In Action Series. Manning, 2003. isbn: 9781930110977.

[HH73]

R.W. Hamming und R.W. Hamming. Numerical Methods for Scientists and Engineers. Dover Books on Mathematics Series. Dover,
1973. isbn: 9780486652412.

[Hof99]

D.R. Hofstadter. Gödel, Escher, Bach: An Eternal Golden Braid.
Basic Books. Basic Books, 1999. isbn: 9780465026562.

[Mar13]

Christian Dietrich Markus Voelter Sebastian Benz. DSL Engineering - Designing, Implementing and Using Domain-Speciﬁc Languages. dslbook.org, 2013. isbn: 978-1-4812-1858-0. url: http://
www.dslbook.org.

[Mur+05]

Makoto Murata u. a. »Taxonomy of XML schema languages using
formal language theory«. In: ACM Trans. Internet Technol. 5.4
(Nov. 2005), S. 660–704. issn: 1533-5399. doi: 10.1145/1111627.
1111631. url: http://doi.acm.org/10.1145/1111627.1111631.

[Ött13]

Tim Ötting. www.soundslikecotton.com. 20. Juni 2013. url: http:
//www.soundslikecotton.com/.

[Pas13]

Kathrin Passig. www.zufallsshirt.de. 20. Juli 2013. url: http://
zufallsshirt.de/.

[Per82]

Alan J. Perlis. »Special Feature: Epigrams on programming«. In:
SIGPLAN Not. 17.9 (Sep. 1982), S. 7–13. issn: 0362-1340.

F

Literaturverzeichnis

M von N

[PK12]

Franz Puntigam und Andreas Krall. Objektorientierte Programmiertechniken. 2012.

[Til09]

Stefan Tilkov. REST und HTTP: Einsatz der Architektur des Web
für Integrationsszenarien. Heidelberg: dpunkt, 2009. isbn: 978-389864-583-6.

[W3C08]

W3C. Extensible Markup Language (XML) 1.0 (Fifth Edition).
26. Nov. 2008. url: http : / / www . w3 . org / TR / 2008 / REC - xml 20081126/ (besucht am 25. 06. 2013).

[W3C12]

W3C. W3C XML Schema Deﬁnition Language (XSD) 1.1 Part 1:
Structures. 5. Apr. 2012. url: http://www.w3.org/TR/2012/RECxmlschema11-1-20120405/ (besucht am 30. 06. 2013).

[Wes+01]

A. Westerinen u. a. »RFC 3198, Terminology for Policy-Based Management«. In: (Nov. 2001). url: http://tools.ietf.org/html/
rfc3198.

[Wik13a]

Wikipedia. OSI model. 30. Sep. 2013. url: \url{http : / / en .
wikipedia.org/w/index.php?title=OSI_model&oldid=574771928}.

[Wik13b]

Wikipedia. Uniform resource name. 30. Sep. 2013. url: \url{http:
//en.wikipedia.org/w/index.php?title=Uniform_resource_
name&oldid=563710451}.

[Wik13c]

Wikipedia. XML — Wikipedia, The Free Encyclopedia. 2013. url:
http : / / en . wikipedia . org / w / index . php ? title = XML & oldid =
561587115 (besucht am 26. 06. 2013).

[WO08]

G. Wilson und A. Oram. Beautiful Code: Leading Programmers Explain How They Think. O’Reilly Media, 2008. isbn: 9780596554675.

F

N von N

BibTEX Eintrag
@phdthesis{AndreasLinz2013,
type = {Bachelorarbeit}
author = {Linz, Andreas},
year = {2013},
month = {10},
day = {2},
timestamp = {2013102},
title = {Generierung und Design einer Client-Bibliothek für einen RESTful
Web Service am Beispiel der Spreadshirt-API},
school = {HTWK-Leipzig},
pdf = {http://www.klingt.net/bachelor/thesis/thesis.pdf}
%ToDo: PUT IN THE URL
}

F

